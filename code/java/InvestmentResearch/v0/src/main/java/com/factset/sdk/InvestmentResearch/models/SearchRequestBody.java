/*
 * Investment Research API
 *  The Investment Research API provides a comprehensive set of functionalities for searching and retrieving research reports and documents from various contributors.  This API is designed to expose document search and document retrieval functionality. A document search will allow a request to query FactSet document databases based on certain search criteria specified in the request.  FactSet collects research reports and models from brokers, independent research providers, market research firms, rating agencies, and other publishers of research. These documents are processed and made available to clients within about two minutes of receipt.  FactSet delivers this content through two main products:  **FactSet Research Connect** – real-time research for investment managers entitled by the contributors to access the content.  **FactSet Aftermarket Research** – delayed research for investment bankers permitted by contributors to purchase the research.  The meta endpoints namely time-zones, categories, research-contributors, research-analysts, security-types and asset-types provide comprehensive lists of data that is used in the research endpoints.    
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.InvestmentResearch.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.time.LocalDate;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.InvestmentResearch.JSON;


/**
 * Search request body elements
 */
@ApiModel(description = "Search request body elements")
@JsonPropertyOrder({
  SearchRequestBody.JSON_PROPERTY_IDS,
  SearchRequestBody.JSON_PROPERTY_START_DATE,
  SearchRequestBody.JSON_PROPERTY_END_DATE,
  SearchRequestBody.JSON_PROPERTY_START_DATE_RELATIVE,
  SearchRequestBody.JSON_PROPERTY_END_DATE_RELATIVE,
  SearchRequestBody.JSON_PROPERTY_SOURCES,
  SearchRequestBody.JSON_PROPERTY_TIMEZONE,
  SearchRequestBody.JSON_PROPERTY_CATEGORIES,
  SearchRequestBody.JSON_PROPERTY_PRIMARY_ID,
  SearchRequestBody.JSON_PROPERTY_SEARCH_TEXT,
  SearchRequestBody.JSON_PROPERTY_CONTRIBUTOR_ID,
  SearchRequestBody.JSON_PROPERTY_ANALYST_ID,
  SearchRequestBody.JSON_PROPERTY_REPORT_FOCI,
  SearchRequestBody.JSON_PROPERTY_SECURITY_TYPES,
  SearchRequestBody.JSON_PROPERTY_ASSET_TYPES,
  SearchRequestBody.JSON_PROPERTY_ASSET_CLASSES,
  SearchRequestBody.JSON_PROPERTY_COVERAGE_ACTIONS,
  SearchRequestBody.JSON_PROPERTY_COMPILATION_INDICATORS,
  SearchRequestBody.JSON_PROPERTY_DISCIPLINES,
  SearchRequestBody.JSON_PROPERTY_ISSUER_TYPES,
  SearchRequestBody.JSON_PROPERTY_PERIODICITIES,
  SearchRequestBody.JSON_PROPERTY_PURPOSES,
  SearchRequestBody.JSON_PROPERTY_RATING_ACTIONS,
  SearchRequestBody.JSON_PROPERTY_RESEARCH_APPROACHES,
  SearchRequestBody.JSON_PROPERTY_TARGET_ACTIONS,
  SearchRequestBody.JSON_PROPERTY_WEIGHTING_ACTIONS
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")

public class SearchRequestBody implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_IDS = "ids";
  private java.util.List<String> ids = new java.util.ArrayList<>();

  public static final String JSON_PROPERTY_START_DATE = "startDate";
  private LocalDate startDate;

  public static final String JSON_PROPERTY_END_DATE = "endDate";
  private LocalDate endDate;

  public static final String JSON_PROPERTY_START_DATE_RELATIVE = "startDateRelative";
  private Integer startDateRelative;

  public static final String JSON_PROPERTY_END_DATE_RELATIVE = "endDateRelative";
  private Integer endDateRelative;

  /**
   * Gets or Sets sources
   */
  public enum SourcesEnum {
    FRC("FRC"),
    
    AMR("AMR");

    private String value;

    SourcesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SourcesEnum fromValue(String value) {
      for (SourcesEnum b : SourcesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_SOURCES = "sources";
  private java.util.Set<SourcesEnum> sources = null;

  public static final String JSON_PROPERTY_TIMEZONE = "timezone";
  private String timezone = "America/New_York";

  public static final String JSON_PROPERTY_CATEGORIES = "categories";
  private java.util.List<String> categories = null;

  public static final String JSON_PROPERTY_PRIMARY_ID = "primaryId";
  private Boolean primaryId = false;

  public static final String JSON_PROPERTY_SEARCH_TEXT = "searchText";
  private String searchText;

  public static final String JSON_PROPERTY_CONTRIBUTOR_ID = "contributorId";
  private java.util.List<Integer> contributorId = null;

  public static final String JSON_PROPERTY_ANALYST_ID = "analystId";
  private java.util.List<Integer> analystId = null;

  /**
   * Gets or Sets reportFoci
   */
  public enum ReportFociEnum {
    ISSUER("Issuer"),
    
    SECTORINDUSTRY("SectorIndustry"),
    
    REGION("Region"),
    
    COUNTRY("Country"),
    
    ASSETCLASS("AssetClass"),
    
    ASSETTYPE("AssetType"),
    
    SECURITYTYPE("SecurityType"),
    
    DISCIPLINE("Discipline"),
    
    INDEX("Index"),
    
    EXCHANGE("Exchange"),
    
    MARKET("Market");

    private String value;

    ReportFociEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static ReportFociEnum fromValue(String value) {
      for (ReportFociEnum b : ReportFociEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_REPORT_FOCI = "reportFoci";
  private java.util.Set<ReportFociEnum> reportFoci = null;

  public static final String JSON_PROPERTY_SECURITY_TYPES = "securityTypes";
  private java.util.List<String> securityTypes = null;

  public static final String JSON_PROPERTY_ASSET_TYPES = "assetTypes";
  private java.util.List<String> assetTypes = null;

  /**
   * Gets or Sets assetClasses
   */
  public enum AssetClassesEnum {
    COMMODITY("Commodity"),
    
    CURRENCY("Currency"),
    
    EQUITY("Equity"),
    
    FIXEDINCOME("FixedIncome");

    private String value;

    AssetClassesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AssetClassesEnum fromValue(String value) {
      for (AssetClassesEnum b : AssetClassesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_ASSET_CLASSES = "assetClasses";
  private java.util.Set<AssetClassesEnum> assetClasses = null;

  /**
   * Gets or Sets coverageActions
   */
  public enum CoverageActionsEnum {
    DROP("Drop"),
    
    INITIATE("Initiate"),
    
    RESUME("Resume"),
    
    SUSPEND("Suspend");

    private String value;

    CoverageActionsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static CoverageActionsEnum fromValue(String value) {
      for (CoverageActionsEnum b : CoverageActionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_COVERAGE_ACTIONS = "coverageActions";
  private java.util.Set<CoverageActionsEnum> coverageActions = null;

  public static final String JSON_PROPERTY_COMPILATION_INDICATORS = "compilationIndicators";
  private Boolean compilationIndicators;

  /**
   * Gets or Sets disciplines
   */
  public enum DisciplinesEnum {
    INVESTMENT("Investment"),
    
    STRATEGY("Strategy"),
    
    ECONOMICS("Economics");

    private String value;

    DisciplinesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static DisciplinesEnum fromValue(String value) {
      for (DisciplinesEnum b : DisciplinesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_DISCIPLINES = "disciplines";
  private java.util.Set<DisciplinesEnum> disciplines = null;

  /**
   * Gets or Sets issuerTypes
   */
  public enum IssuerTypesEnum {
    AGENCY("Agency"),
    
    CORPORATE("Corporate"),
    
    EXCHANGE("Exchange"),
    
    MUNICIPALITY("Municipality"),
    
    MUTUALFUND("MutualFund"),
    
    REIT("REIT"),
    
    SOVEREIGN("Sovereign"),
    
    SUPRANATIONALORGANIZATIONS("SupranationalOrganizations");

    private String value;

    IssuerTypesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static IssuerTypesEnum fromValue(String value) {
      for (IssuerTypesEnum b : IssuerTypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_ISSUER_TYPES = "issuerTypes";
  private java.util.Set<IssuerTypesEnum> issuerTypes = null;

  /**
   * Gets or Sets periodicities
   */
  public enum PeriodicitiesEnum {
    ANNUALLY("Annually"),
    
    DAILY("Daily"),
    
    EVERYTWOWEEKS("EveryTwoWeeks"),
    
    HOURLY("Hourly"),
    
    INTRADAY("IntraDay"),
    
    MONTHLY("Monthly"),
    
    NONE("None"),
    
    OTHER("Other"),
    
    QUARTERLY("Quarterly"),
    
    SEMIANNUALLY("SemiAnnually"),
    
    WEEKLY("Weekly");

    private String value;

    PeriodicitiesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PeriodicitiesEnum fromValue(String value) {
      for (PeriodicitiesEnum b : PeriodicitiesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PERIODICITIES = "periodicities";
  private java.util.Set<PeriodicitiesEnum> periodicities = null;

  /**
   * Gets or Sets purposes
   */
  public enum PurposesEnum {
    ACTION("Action"),
    
    INFLUENCE("Influence"),
    
    EDUCATION("Education");

    private String value;

    PurposesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PurposesEnum fromValue(String value) {
      for (PurposesEnum b : PurposesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PURPOSES = "purposes";
  private java.util.Set<PurposesEnum> purposes = null;

  /**
   * Gets or Sets ratingActions
   */
  public enum RatingActionsEnum {
    AFFIRMED("Affirmed"),
    
    DOWNGRADE("Downgrade"),
    
    DROP("Drop"),
    
    INITIATE("Initiate"),
    
    NEGATIVEOUTLOOK("NegativeOutlook"),
    
    NEWRATING("NewRating"),
    
    POSITIVEOUTLOOK("PositiveOutlook"),
    
    RATINGRESTORED("RatingRestored"),
    
    RATINGWITHDRAWN("RatingWithdrawn"),
    
    REITERATE("Reiterate"),
    
    REVIEWDIRECTIONUNCERTAIN("ReviewDirectionUncertain"),
    
    REVIEWFORDOWNGRADE("ReviewForDowngrade"),
    
    REVIEWFORUPGRADE("ReviewForUpgrade"),
    
    REVISE("Revise"),
    
    UPGRADE("Upgrade");

    private String value;

    RatingActionsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RatingActionsEnum fromValue(String value) {
      for (RatingActionsEnum b : RatingActionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RATING_ACTIONS = "ratingActions";
  private java.util.Set<RatingActionsEnum> ratingActions = null;

  /**
   * Gets or Sets researchApproaches
   */
  public enum ResearchApproachesEnum {
    FUNDAMENTAL("Fundamental"),
    
    QUANTITATIVE("Quantitative"),
    
    TECHNICAL("Technical");

    private String value;

    ResearchApproachesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static ResearchApproachesEnum fromValue(String value) {
      for (ResearchApproachesEnum b : ResearchApproachesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_RESEARCH_APPROACHES = "researchApproaches";
  private java.util.Set<ResearchApproachesEnum> researchApproaches = null;

  /**
   * Gets or Sets targetActions
   */
  public enum TargetActionsEnum {
    DECREASE("Decrease"),
    
    INCREASE("Increase"),
    
    REITERATE("Reiterate"),
    
    UPDATE("Update");

    private String value;

    TargetActionsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TargetActionsEnum fromValue(String value) {
      for (TargetActionsEnum b : TargetActionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_TARGET_ACTIONS = "targetActions";
  private java.util.Set<TargetActionsEnum> targetActions = null;

  /**
   * Gets or Sets weightingActions
   */
  public enum WeightingActionsEnum {
    DECREASE("Decrease"),
    
    INCREASE("Increase"),
    
    REITERATE("Reiterate"),
    
    UPDATE("Update");

    private String value;

    WeightingActionsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WeightingActionsEnum fromValue(String value) {
      for (WeightingActionsEnum b : WeightingActionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_WEIGHTING_ACTIONS = "weightingActions";
  private java.util.Set<WeightingActionsEnum> weightingActions = null;

  public SearchRequestBody() { 
  }

  @JsonCreator
  public SearchRequestBody(
    @JsonProperty(value=JSON_PROPERTY_IDS, required=true) java.util.List<String> ids
  ) {
    this();
    this.ids = ids;
  }

  public SearchRequestBody ids(java.util.List<String> ids) {
    this.ids = ids;
    return this;
  }

  public SearchRequestBody addIdsItem(String idsItem) {
    this.ids.add(idsItem);
    return this;
  }

   /**
   * Requested symbols or securities.  This is a comma-separated list with a maximum limit of 1000.  Each symbol can be a FactSet exchange symbol, CUSIP, ISIN, Entity ID and SEDOL. 
   * @return ids
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(example = "[\"MODN-US\"]", required = true, value = "Requested symbols or securities.  This is a comma-separated list with a maximum limit of 1000.  Each symbol can be a FactSet exchange symbol, CUSIP, ISIN, Entity ID and SEDOL. ")
  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public java.util.List<String> getIds() {
    return ids;
  }


  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIds(java.util.List<String> ids) {
    this.ids = ids;
  }


  public SearchRequestBody startDate(LocalDate startDate) {
    this.startDate = startDate;
    return this;
  }

   /**
   * Start Date. Format is YYYY-MM-DD. If the parameter is not provided, will return the today&#39;s results. 
   * @return startDate
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Fri Dec 21 00:00:00 UTC 2012", value = "Start Date. Format is YYYY-MM-DD. If the parameter is not provided, will return the today's results. ")
  @JsonProperty(JSON_PROPERTY_START_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public LocalDate getStartDate() {
    return startDate;
  }


  @JsonProperty(JSON_PROPERTY_START_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartDate(LocalDate startDate) {
    this.startDate = startDate;
  }


  public SearchRequestBody endDate(LocalDate endDate) {
    this.endDate = endDate;
    return this;
  }

   /**
   * End Date. Format is YYYY-MM-DD. If the parameter is not provided, will return the today&#39;s results. 
   * @return endDate
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Sun Dec 23 00:00:00 UTC 2012", value = "End Date. Format is YYYY-MM-DD. If the parameter is not provided, will return the today's results. ")
  @JsonProperty(JSON_PROPERTY_END_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public LocalDate getEndDate() {
    return endDate;
  }


  @JsonProperty(JSON_PROPERTY_END_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEndDate(LocalDate endDate) {
    this.endDate = endDate;
  }


  public SearchRequestBody startDateRelative(Integer startDateRelative) {
    this.startDateRelative = startDateRelative;
    return this;
  }

   /**
   * The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.* 
   * @return startDateRelative
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "-1", value = "The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: '0' for today, '-1' for yesterday, '-2' for two days ago, and so forth. Negative values are used to represent past dates.   - *Either `startDate` or `startDateRelative` should be used, but not both.* - *If both `startDate` and `startDateRelative` are provided in the same request, the API will return an error.* - *If users provide future dates in requests for `startDate` or `startDateRelative`, the API will not return any data.* ")
  @JsonProperty(JSON_PROPERTY_START_DATE_RELATIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getStartDateRelative() {
    return startDateRelative;
  }


  @JsonProperty(JSON_PROPERTY_START_DATE_RELATIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartDateRelative(Integer startDateRelative) {
    this.startDateRelative = startDateRelative;
  }


  public SearchRequestBody endDateRelative(Integer endDateRelative) {
    this.endDateRelative = endDateRelative;
    return this;
  }

   /**
   * The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data. 
   * @return endDateRelative
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "-1", value = "The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: '0' for today, '-1' for yesterday, '-2' for two days ago, and so forth. Negative values are used to represent past dates.  - Either `endDate` or `endDateRelative` should be used, but not both. - If both `endDate` and `endDateRelative` are provided in the same request, the API will return an error. - If users provide future dates in requests for `endDate` or `endDateRelative`, the API will not return any data. ")
  @JsonProperty(JSON_PROPERTY_END_DATE_RELATIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getEndDateRelative() {
    return endDateRelative;
  }


  @JsonProperty(JSON_PROPERTY_END_DATE_RELATIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEndDateRelative(Integer endDateRelative) {
    this.endDateRelative = endDateRelative;
  }


  public SearchRequestBody sources(java.util.Set<SourcesEnum> sources) {
    this.sources = sources;
    return this;
  }

  public SearchRequestBody addSourcesItem(SourcesEnum sourcesItem) {
    if (this.sources == null) {
      this.sources = new java.util.LinkedHashSet<>();
    }
    this.sources.add(sourcesItem);
    return this;
  }

   /**
   * Code for document source to include.  This is a comma-separated list. Available values:-     * FRC - FactSet Research Connect      * AMR - Aftermarket Research    If this parameter is not provided, data is queried from the entitled sources.
   * @return sources
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Code for document source to include.  This is a comma-separated list. Available values:-     * FRC - FactSet Research Connect      * AMR - Aftermarket Research    If this parameter is not provided, data is queried from the entitled sources.")
  @JsonProperty(JSON_PROPERTY_SOURCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<SourcesEnum> getSources() {
    return sources;
  }


  @JsonProperty(JSON_PROPERTY_SOURCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSources(java.util.Set<SourcesEnum> sources) {
    this.sources = sources;
  }


  public SearchRequestBody timezone(String timezone) {
    this.timezone = timezone;
    return this;
  }

   /**
   * Returns a list of all time zones supported by the API, formatted in POSIX style (e.g., &#x60;America/New_York&#x60;, &#x60;Africa/Malabo&#x60;). These time zones are automatically adjusted for daylight saving time where applicable. This list is used for setting or converting story dates and times accurately across different regions.
   * @return timezone
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Returns a list of all time zones supported by the API, formatted in POSIX style (e.g., `America/New_York`, `Africa/Malabo`). These time zones are automatically adjusted for daylight saving time where applicable. This list is used for setting or converting story dates and times accurately across different regions.")
  @JsonProperty(JSON_PROPERTY_TIMEZONE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTimezone() {
    return timezone;
  }


  @JsonProperty(JSON_PROPERTY_TIMEZONE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public SearchRequestBody categories(java.util.List<String> categories) {
    this.categories = categories;
    return this;
  }

  public SearchRequestBody addCategoriesItem(String categoriesItem) {
    if (this.categories == null) {
      this.categories = new java.util.ArrayList<>();
    }
    this.categories.add(categoriesItem);
    return this;
  }

   /**
   * Code for categories to include.  This is a comma-separated list. Use the &#x60;&#x60;&#x60;/meta/categories&#x60;&#x60;&#x60; endpoint to get the list of available categories.  Default &#x3D; All categories.
   * @return categories
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[\"SB:ANLCH\",\"IN:OIL\"]", value = "Code for categories to include.  This is a comma-separated list. Use the ```/meta/categories``` endpoint to get the list of available categories.  Default = All categories.")
  @JsonProperty(JSON_PROPERTY_CATEGORIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<String> getCategories() {
    return categories;
  }


  @JsonProperty(JSON_PROPERTY_CATEGORIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCategories(java.util.List<String> categories) {
    this.categories = categories;
  }


  public SearchRequestBody primaryId(Boolean primaryId) {
    this.primaryId = primaryId;
    return this;
  }

   /**
   * Type of identifier search — set to true to search by primary identifier.
   * @return primaryId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Type of identifier search — set to true to search by primary identifier.")
  @JsonProperty(JSON_PROPERTY_PRIMARY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getPrimaryId() {
    return primaryId;
  }


  @JsonProperty(JSON_PROPERTY_PRIMARY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPrimaryId(Boolean primaryId) {
    this.primaryId = primaryId;
  }


  public SearchRequestBody searchText(String searchText) {
    this.searchText = searchText;
    return this;
  }

   /**
   * Restricts the search to include only document stories that include the searched text. This parameter supports boolean operators as well. 
   * @return searchText
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Officer", value = "Restricts the search to include only document stories that include the searched text. This parameter supports boolean operators as well. ")
  @JsonProperty(JSON_PROPERTY_SEARCH_TEXT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSearchText() {
    return searchText;
  }


  @JsonProperty(JSON_PROPERTY_SEARCH_TEXT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSearchText(String searchText) {
    this.searchText = searchText;
  }


  public SearchRequestBody contributorId(java.util.List<Integer> contributorId) {
    this.contributorId = contributorId;
    return this;
  }

  public SearchRequestBody addContributorIdItem(Integer contributorIdItem) {
    if (this.contributorId == null) {
      this.contributorId = new java.util.ArrayList<>();
    }
    this.contributorId.add(contributorIdItem);
    return this;
  }

   /**
   * One or more contributor codes. This is a comma-separated list. Use the &#x60;&#x60;&#x60;/meta/research-contributors&#x60;&#x60;&#x60; endpoint to get the list of permissioned contributors. If this parameter is not used, by default will get all permissioned contributors.
   * @return contributorId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[20120205,21069618]", value = "One or more contributor codes. This is a comma-separated list. Use the ```/meta/research-contributors``` endpoint to get the list of permissioned contributors. If this parameter is not used, by default will get all permissioned contributors.")
  @JsonProperty(JSON_PROPERTY_CONTRIBUTOR_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<Integer> getContributorId() {
    return contributorId;
  }


  @JsonProperty(JSON_PROPERTY_CONTRIBUTOR_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContributorId(java.util.List<Integer> contributorId) {
    this.contributorId = contributorId;
  }


  public SearchRequestBody analystId(java.util.List<Integer> analystId) {
    this.analystId = analystId;
    return this;
  }

  public SearchRequestBody addAnalystIdItem(Integer analystIdItem) {
    if (this.analystId == null) {
      this.analystId = new java.util.ArrayList<>();
    }
    this.analystId.add(analystIdItem);
    return this;
  }

   /**
   * One or more analyst codes of authors who were the primary or secondary authors of the documents. This is a comma-separated list. Use the &#x60;&#x60;&#x60;/meta/research-analysts&#x60;&#x60;&#x60; endpoint to get the list of permissioned analysts for the provided contibutor ID. If this parameter is omitted, the result set is not filtered by analyst code, and the corresponding analyst field(s) and details are not returned in the response.
   * @return analystId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[6885167,6885168]", value = "One or more analyst codes of authors who were the primary or secondary authors of the documents. This is a comma-separated list. Use the ```/meta/research-analysts``` endpoint to get the list of permissioned analysts for the provided contibutor ID. If this parameter is omitted, the result set is not filtered by analyst code, and the corresponding analyst field(s) and details are not returned in the response.")
  @JsonProperty(JSON_PROPERTY_ANALYST_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<Integer> getAnalystId() {
    return analystId;
  }


  @JsonProperty(JSON_PROPERTY_ANALYST_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAnalystId(java.util.List<Integer> analystId) {
    this.analystId = analystId;
  }


  public SearchRequestBody reportFoci(java.util.Set<ReportFociEnum> reportFoci) {
    this.reportFoci = reportFoci;
    return this;
  }

  public SearchRequestBody addReportFociItem(ReportFociEnum reportFociItem) {
    if (this.reportFoci == null) {
      this.reportFoci = new java.util.LinkedHashSet<>();
    }
    this.reportFoci.add(reportFociItem);
    return this;
  }

   /**
   * One or more classification codes indicating the primary focus of the document. These codes help categorize the content based on various dimensions such as the subject entity, geographic scope, asset characteristics, and financial classification. If this parameter is omitted, the result set is not filtered by reportFoci code, and the corresponding report focus fields and details are not returned in the response. The supported types are:    - Issuer - Identifies the specific company or entity the document is about.   - SectorIndustry - Indicates the relevant economic sector and industry classification.   - Region - Denotes the broader geographic area covered.   - Country - Specifies the particular country in focus.   - AssetClass - Defines the general asset category (e.g., Equity, Fixed Income, Commodities).   - AssetType - Represents the specific type of asset within the asset class.   - SecurityType - Describes the structure or legal form of the security.   - Discipline - Indicates the analytical lens or domain.   - Index - References a benchmark index discussed or tracked in the document.   - Exchange - Points to the stock or commodity exchange relevant to the content.   - Market - Represents the broader financial market or segment involved. 
   * @return reportFoci
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more classification codes indicating the primary focus of the document. These codes help categorize the content based on various dimensions such as the subject entity, geographic scope, asset characteristics, and financial classification. If this parameter is omitted, the result set is not filtered by reportFoci code, and the corresponding report focus fields and details are not returned in the response. The supported types are:    - Issuer - Identifies the specific company or entity the document is about.   - SectorIndustry - Indicates the relevant economic sector and industry classification.   - Region - Denotes the broader geographic area covered.   - Country - Specifies the particular country in focus.   - AssetClass - Defines the general asset category (e.g., Equity, Fixed Income, Commodities).   - AssetType - Represents the specific type of asset within the asset class.   - SecurityType - Describes the structure or legal form of the security.   - Discipline - Indicates the analytical lens or domain.   - Index - References a benchmark index discussed or tracked in the document.   - Exchange - Points to the stock or commodity exchange relevant to the content.   - Market - Represents the broader financial market or segment involved. ")
  @JsonProperty(JSON_PROPERTY_REPORT_FOCI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<ReportFociEnum> getReportFoci() {
    return reportFoci;
  }


  @JsonProperty(JSON_PROPERTY_REPORT_FOCI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReportFoci(java.util.Set<ReportFociEnum> reportFoci) {
    this.reportFoci = reportFoci;
  }


  public SearchRequestBody securityTypes(java.util.List<String> securityTypes) {
    this.securityTypes = securityTypes;
    return this;
  }

  public SearchRequestBody addSecurityTypesItem(String securityTypesItem) {
    if (this.securityTypes == null) {
      this.securityTypes = new java.util.ArrayList<>();
    }
    this.securityTypes.add(securityTypesItem);
    return this;
  }

   /**
   * One or more codes indicating security types. A This is a comma-separated list. Use the &#x60;&#x60;&#x60;/meta/security-types&#x60;&#x60;&#x60; endpoint to get the list of available security types. If this parameter is omitted, the result set is not filtered by security type, and the corresponding security type fields and details are not returned in the response.
   * @return securityTypes
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[\"Agencycredit\",\"Agencypassthroughsecurities\"]", value = "One or more codes indicating security types. A This is a comma-separated list. Use the ```/meta/security-types``` endpoint to get the list of available security types. If this parameter is omitted, the result set is not filtered by security type, and the corresponding security type fields and details are not returned in the response.")
  @JsonProperty(JSON_PROPERTY_SECURITY_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<String> getSecurityTypes() {
    return securityTypes;
  }


  @JsonProperty(JSON_PROPERTY_SECURITY_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSecurityTypes(java.util.List<String> securityTypes) {
    this.securityTypes = securityTypes;
  }


  public SearchRequestBody assetTypes(java.util.List<String> assetTypes) {
    this.assetTypes = assetTypes;
    return this;
  }

  public SearchRequestBody addAssetTypesItem(String assetTypesItem) {
    if (this.assetTypes == null) {
      this.assetTypes = new java.util.ArrayList<>();
    }
    this.assetTypes.add(assetTypesItem);
    return this;
  }

   /**
   * One or more codes indicating asset types. A This is a comma-separated list. Use the &#x60;&#x60;&#x60;/meta/asset-types&#x60;&#x60;&#x60; endpoint to get the list of available asset-types. If this parameter is omitted, the result set is not filtered by asset types, and the corresponding asset type field and details are not returned in the response.
   * @return assetTypes
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[\"Agencycredit\",\"Assetbackedcredit\"]", value = "One or more codes indicating asset types. A This is a comma-separated list. Use the ```/meta/asset-types``` endpoint to get the list of available asset-types. If this parameter is omitted, the result set is not filtered by asset types, and the corresponding asset type field and details are not returned in the response.")
  @JsonProperty(JSON_PROPERTY_ASSET_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<String> getAssetTypes() {
    return assetTypes;
  }


  @JsonProperty(JSON_PROPERTY_ASSET_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAssetTypes(java.util.List<String> assetTypes) {
    this.assetTypes = assetTypes;
  }


  public SearchRequestBody assetClasses(java.util.Set<AssetClassesEnum> assetClasses) {
    this.assetClasses = assetClasses;
    return this;
  }

  public SearchRequestBody addAssetClassesItem(AssetClassesEnum assetClassesItem) {
    if (this.assetClasses == null) {
      this.assetClasses = new java.util.LinkedHashSet<>();
    }
    this.assetClasses.add(assetClassesItem);
    return this;
  }

   /**
   * One or more codes indicating asset classes covered in the document. The supported classifications are:    - Commodity - Includes physical goods like oil, gold, and agricultural products.   - Currency - Covers foreign exchange and currency-related instruments.   - Equity - Refers to ownership interests such as stocks or shares.   - FixedIncome - Includes debt instruments like bonds and treasury bills.      If this parameter is omitted, the result set is not filtered by asset class, and the corresponding fields and details are not returned in the response. 
   * @return assetClasses
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating asset classes covered in the document. The supported classifications are:    - Commodity - Includes physical goods like oil, gold, and agricultural products.   - Currency - Covers foreign exchange and currency-related instruments.   - Equity - Refers to ownership interests such as stocks or shares.   - FixedIncome - Includes debt instruments like bonds and treasury bills.      If this parameter is omitted, the result set is not filtered by asset class, and the corresponding fields and details are not returned in the response. ")
  @JsonProperty(JSON_PROPERTY_ASSET_CLASSES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<AssetClassesEnum> getAssetClasses() {
    return assetClasses;
  }


  @JsonProperty(JSON_PROPERTY_ASSET_CLASSES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAssetClasses(java.util.Set<AssetClassesEnum> assetClasses) {
    this.assetClasses = assetClasses;
  }


  public SearchRequestBody coverageActions(java.util.Set<CoverageActionsEnum> coverageActions) {
    this.coverageActions = coverageActions;
    return this;
  }

  public SearchRequestBody addCoverageActionsItem(CoverageActionsEnum coverageActionsItem) {
    if (this.coverageActions == null) {
      this.coverageActions = new java.util.LinkedHashSet<>();
    }
    this.coverageActions.add(coverageActionsItem);
    return this;
  }

   /**
   * One or more codes indicating coverage actions discussed in the document. The supported actions are:    - Drop - Permanent discontinuation of research coverage. No further updates or publications will be issued for the entity.      - Initiate - Formal commencement of research coverage. Typically includes an initial report and sets ongoing analytical attention.      - Resume - Reinstatement of previously suspended or dropped coverage. Research publication and updates resume for the entity.      - Suspend - Temporary halt in research coverage. No updates will be issued during this period, but coverage may be resumed later.       If this parameter is omitted, the result set is not filtered by coverage action, and the corresponding coverage action field and details are not returned in the response. 
   * @return coverageActions
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating coverage actions discussed in the document. The supported actions are:    - Drop - Permanent discontinuation of research coverage. No further updates or publications will be issued for the entity.      - Initiate - Formal commencement of research coverage. Typically includes an initial report and sets ongoing analytical attention.      - Resume - Reinstatement of previously suspended or dropped coverage. Research publication and updates resume for the entity.      - Suspend - Temporary halt in research coverage. No updates will be issued during this period, but coverage may be resumed later.       If this parameter is omitted, the result set is not filtered by coverage action, and the corresponding coverage action field and details are not returned in the response. ")
  @JsonProperty(JSON_PROPERTY_COVERAGE_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<CoverageActionsEnum> getCoverageActions() {
    return coverageActions;
  }


  @JsonProperty(JSON_PROPERTY_COVERAGE_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCoverageActions(java.util.Set<CoverageActionsEnum> coverageActions) {
    this.coverageActions = coverageActions;
  }


  public SearchRequestBody compilationIndicators(Boolean compilationIndicators) {
    this.compilationIndicators = compilationIndicators;
    return this;
  }

   /**
   * An indication of whether the document contains new material or is a compilation/summary of separately published material. If this parameter is not used, it will not return whether the record in the result has complilation indicator or not.    
   * @return compilationIndicators
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "An indication of whether the document contains new material or is a compilation/summary of separately published material. If this parameter is not used, it will not return whether the record in the result has complilation indicator or not.    ")
  @JsonProperty(JSON_PROPERTY_COMPILATION_INDICATORS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getCompilationIndicators() {
    return compilationIndicators;
  }


  @JsonProperty(JSON_PROPERTY_COMPILATION_INDICATORS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCompilationIndicators(Boolean compilationIndicators) {
    this.compilationIndicators = compilationIndicators;
  }


  public SearchRequestBody disciplines(java.util.Set<DisciplinesEnum> disciplines) {
    this.disciplines = disciplines;
    return this;
  }

  public SearchRequestBody addDisciplinesItem(DisciplinesEnum disciplinesItem) {
    if (this.disciplines == null) {
      this.disciplines = new java.util.LinkedHashSet<>();
    }
    this.disciplines.add(disciplinesItem);
    return this;
  }

   /**
   * One or more codes indicating the disciplines reflected in the document. The supported disciplines:   - Investment - Coverage related to investment assets, individual securities, or portfolio-level analysis.   - Strategy - Coverage concerning broader investment strategies, asset allocation, and portfolio construction insights.   - Economics - Coverage involving economic analysis, including macroeconomic trends, monetary policy, inflation, GDP, and related indicators.    If this parameter is omitted, the result set is not filtered by discipline, and the corresponding discipline field and details are not returned in the response. 
   * @return disciplines
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating the disciplines reflected in the document. The supported disciplines:   - Investment - Coverage related to investment assets, individual securities, or portfolio-level analysis.   - Strategy - Coverage concerning broader investment strategies, asset allocation, and portfolio construction insights.   - Economics - Coverage involving economic analysis, including macroeconomic trends, monetary policy, inflation, GDP, and related indicators.    If this parameter is omitted, the result set is not filtered by discipline, and the corresponding discipline field and details are not returned in the response. ")
  @JsonProperty(JSON_PROPERTY_DISCIPLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<DisciplinesEnum> getDisciplines() {
    return disciplines;
  }


  @JsonProperty(JSON_PROPERTY_DISCIPLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDisciplines(java.util.Set<DisciplinesEnum> disciplines) {
    this.disciplines = disciplines;
  }


  public SearchRequestBody issuerTypes(java.util.Set<IssuerTypesEnum> issuerTypes) {
    this.issuerTypes = issuerTypes;
    return this;
  }

  public SearchRequestBody addIssuerTypesItem(IssuerTypesEnum issuerTypesItem) {
    if (this.issuerTypes == null) {
      this.issuerTypes = new java.util.LinkedHashSet<>();
    }
    this.issuerTypes.add(issuerTypesItem);
    return this;
  }

   /**
   * One or more codes indicating issuer types covered in the document. The supported issuer types:   - Agency - Debt issued by a government-sponsored or supported agency.   - Corporate - Securities issued by private or publicly traded corporations.    - Exchange - Instruments or debt issued via an exchange platform—typically exchange-traded notes or listed debt.   - Municipality - Bonds issued by state, local, or municipal governments.   - MutualFund - Shares issued by an open-end investment fund that pools investor assets to buy securities.   - REIT - Equity or debt securities issued by a Real Estate Investment Trust, which invests in income-generating property.   - Sovereign - Debt issued by a national government.   - SupranationalOrganizations - Debt issued by multinational agencies or international institutions.    If this parameter is omitted, the result set is not filtered by issuer types, and the corresponding issuer type field and details are not returned in the response. 
   * @return issuerTypes
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating issuer types covered in the document. The supported issuer types:   - Agency - Debt issued by a government-sponsored or supported agency.   - Corporate - Securities issued by private or publicly traded corporations.    - Exchange - Instruments or debt issued via an exchange platform—typically exchange-traded notes or listed debt.   - Municipality - Bonds issued by state, local, or municipal governments.   - MutualFund - Shares issued by an open-end investment fund that pools investor assets to buy securities.   - REIT - Equity or debt securities issued by a Real Estate Investment Trust, which invests in income-generating property.   - Sovereign - Debt issued by a national government.   - SupranationalOrganizations - Debt issued by multinational agencies or international institutions.    If this parameter is omitted, the result set is not filtered by issuer types, and the corresponding issuer type field and details are not returned in the response. ")
  @JsonProperty(JSON_PROPERTY_ISSUER_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<IssuerTypesEnum> getIssuerTypes() {
    return issuerTypes;
  }


  @JsonProperty(JSON_PROPERTY_ISSUER_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIssuerTypes(java.util.Set<IssuerTypesEnum> issuerTypes) {
    this.issuerTypes = issuerTypes;
  }


  public SearchRequestBody periodicities(java.util.Set<PeriodicitiesEnum> periodicities) {
    this.periodicities = periodicities;
    return this;
  }

  public SearchRequestBody addPeriodicitiesItem(PeriodicitiesEnum periodicitiesItem) {
    if (this.periodicities == null) {
      this.periodicities = new java.util.LinkedHashSet<>();
    }
    this.periodicities.add(periodicitiesItem);
    return this;
  }

   /**
   * One or more codes indicating the fixed time interval at which the document is published.   The supported periodicities:   - Annually - Document is published once every year.   - Daily - Document is published every day.   - EveryTwoWeeks - Document is published every two weeks (biweekly).   - Hourly - Document is published every hour.   - IntraDay - Document is published multiple times within the same day.   - Monthly - Document is published once every month.   - None - No fixed periodicity; publication is irregular or ad hoc.   - Other - Publication follows a custom or unspecified interval.   - Quarterly - Document is published once every quarter (every three months).   - SemiAnnually - Document is published twice a year.   - Weekly - Document is published once every week.    If this parameter is omitted, the result set is not filtered by periodicities, and the corresponding periodicities field and details are not returned in the response. 
   * @return periodicities
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating the fixed time interval at which the document is published.   The supported periodicities:   - Annually - Document is published once every year.   - Daily - Document is published every day.   - EveryTwoWeeks - Document is published every two weeks (biweekly).   - Hourly - Document is published every hour.   - IntraDay - Document is published multiple times within the same day.   - Monthly - Document is published once every month.   - None - No fixed periodicity; publication is irregular or ad hoc.   - Other - Publication follows a custom or unspecified interval.   - Quarterly - Document is published once every quarter (every three months).   - SemiAnnually - Document is published twice a year.   - Weekly - Document is published once every week.    If this parameter is omitted, the result set is not filtered by periodicities, and the corresponding periodicities field and details are not returned in the response. ")
  @JsonProperty(JSON_PROPERTY_PERIODICITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<PeriodicitiesEnum> getPeriodicities() {
    return periodicities;
  }


  @JsonProperty(JSON_PROPERTY_PERIODICITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPeriodicities(java.util.Set<PeriodicitiesEnum> periodicities) {
    this.periodicities = periodicities;
  }


  public SearchRequestBody purposes(java.util.Set<PurposesEnum> purposes) {
    this.purposes = purposes;
    return this;
  }

  public SearchRequestBody addPurposesItem(PurposesEnum purposesItem) {
    if (this.purposes == null) {
      this.purposes = new java.util.LinkedHashSet<>();
    }
    this.purposes.add(purposesItem);
    return this;
  }

   /**
   * One or more codes indicating the report purpose of the document.   The supported purposes:   - Action - Intended to drive or recommend a specific investment decision or action.   - Influence - Aimed at shaping opinions or market sentiment without directly recommending action.   - Education - Designed to inform or explain concepts, methodologies, or market mechanics.    If this parameter is omitted, the result set is not filtered by purposes, and the corresponding purposes field and details are not returned in the response.  
   * @return purposes
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating the report purpose of the document.   The supported purposes:   - Action - Intended to drive or recommend a specific investment decision or action.   - Influence - Aimed at shaping opinions or market sentiment without directly recommending action.   - Education - Designed to inform or explain concepts, methodologies, or market mechanics.    If this parameter is omitted, the result set is not filtered by purposes, and the corresponding purposes field and details are not returned in the response.  ")
  @JsonProperty(JSON_PROPERTY_PURPOSES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<PurposesEnum> getPurposes() {
    return purposes;
  }


  @JsonProperty(JSON_PROPERTY_PURPOSES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPurposes(java.util.Set<PurposesEnum> purposes) {
    this.purposes = purposes;
  }


  public SearchRequestBody ratingActions(java.util.Set<RatingActionsEnum> ratingActions) {
    this.ratingActions = ratingActions;
    return this;
  }

  public SearchRequestBody addRatingActionsItem(RatingActionsEnum ratingActionsItem) {
    if (this.ratingActions == null) {
      this.ratingActions = new java.util.LinkedHashSet<>();
    }
    this.ratingActions.add(ratingActionsItem);
    return this;
  }

   /**
   * One or more codes indicating rating actions discussed in the document. The supported rating actions:   - Affirmed - Maintains the current rating after review.   - Downgrade - Lowers the rating to a worse category.   - Drop - Removes rating coverage entirely.   - Initiate - Applies a rating for the first time on the entity.   - NegativeOutlook - Assigns a negative outlook without changing the rating.   - NewRating - Introduces a rating where none existed before.   - PositiveOutlook - Assigns a positive outlook without changing the rating.   - RatingRestored - Reinstates a previously withdrawn or suspended rating.   - RatingWithdrawn - Removes the current rating but leaves open resumption.   - Reiterate - Reaffirms the existing rating without change.   - ReviewDirectionUncertain - Places rating under review without a clear direction.   - ReviewForDowngrade - Places rating under review, likely to be downgraded.   - ReviewForUpgrade - Places rating under review, likely to be upgraded.   - Revise - Modifies rating details or scale without changing direction.   - Upgrade - Raises the rating to a better category.        If this parameter is omitted, the result set is not filtered by rating actions, and the corresponding rating actions field and details are not returned in the response.  
   * @return ratingActions
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating rating actions discussed in the document. The supported rating actions:   - Affirmed - Maintains the current rating after review.   - Downgrade - Lowers the rating to a worse category.   - Drop - Removes rating coverage entirely.   - Initiate - Applies a rating for the first time on the entity.   - NegativeOutlook - Assigns a negative outlook without changing the rating.   - NewRating - Introduces a rating where none existed before.   - PositiveOutlook - Assigns a positive outlook without changing the rating.   - RatingRestored - Reinstates a previously withdrawn or suspended rating.   - RatingWithdrawn - Removes the current rating but leaves open resumption.   - Reiterate - Reaffirms the existing rating without change.   - ReviewDirectionUncertain - Places rating under review without a clear direction.   - ReviewForDowngrade - Places rating under review, likely to be downgraded.   - ReviewForUpgrade - Places rating under review, likely to be upgraded.   - Revise - Modifies rating details or scale without changing direction.   - Upgrade - Raises the rating to a better category.        If this parameter is omitted, the result set is not filtered by rating actions, and the corresponding rating actions field and details are not returned in the response.  ")
  @JsonProperty(JSON_PROPERTY_RATING_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<RatingActionsEnum> getRatingActions() {
    return ratingActions;
  }


  @JsonProperty(JSON_PROPERTY_RATING_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRatingActions(java.util.Set<RatingActionsEnum> ratingActions) {
    this.ratingActions = ratingActions;
  }


  public SearchRequestBody researchApproaches(java.util.Set<ResearchApproachesEnum> researchApproaches) {
    this.researchApproaches = researchApproaches;
    return this;
  }

  public SearchRequestBody addResearchApproachesItem(ResearchApproachesEnum researchApproachesItem) {
    if (this.researchApproaches == null) {
      this.researchApproaches = new java.util.LinkedHashSet<>();
    }
    this.researchApproaches.add(researchApproachesItem);
    return this;
  }

   /**
   * One or more codes indicating the research perspective provided in the document.   The supported research approaches:   - Fundamental - Based on analysis of financial statements, industry conditions, and management quality to determine intrinsic value.   - Quantitative - Relies on statistical models, mathematical algorithms, and historical data to identify patterns and signals.   - Technical - Focuses on price charts, trading volume, and market trends to forecast future price movements.     If this parameter is omitted, the result set is not filtered by research approaches, and the corresponding research approaches field and details are not returned in the response.    
   * @return researchApproaches
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating the research perspective provided in the document.   The supported research approaches:   - Fundamental - Based on analysis of financial statements, industry conditions, and management quality to determine intrinsic value.   - Quantitative - Relies on statistical models, mathematical algorithms, and historical data to identify patterns and signals.   - Technical - Focuses on price charts, trading volume, and market trends to forecast future price movements.     If this parameter is omitted, the result set is not filtered by research approaches, and the corresponding research approaches field and details are not returned in the response.    ")
  @JsonProperty(JSON_PROPERTY_RESEARCH_APPROACHES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<ResearchApproachesEnum> getResearchApproaches() {
    return researchApproaches;
  }


  @JsonProperty(JSON_PROPERTY_RESEARCH_APPROACHES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResearchApproaches(java.util.Set<ResearchApproachesEnum> researchApproaches) {
    this.researchApproaches = researchApproaches;
  }


  public SearchRequestBody targetActions(java.util.Set<TargetActionsEnum> targetActions) {
    this.targetActions = targetActions;
    return this;
  }

  public SearchRequestBody addTargetActionsItem(TargetActionsEnum targetActionsItem) {
    if (this.targetActions == null) {
      this.targetActions = new java.util.LinkedHashSet<>();
    }
    this.targetActions.add(targetActionsItem);
    return this;
  }

   /**
   * One or more codes indicating target price actions discussed in the document.   The supported target actions:   - Decrease - Lowers the previously stated target price for a security.   - Increase - Raises the previously stated target price for a security.   - Reiterate - Confirms the existing target price without change.   - Update - Modifies the target price, direction may or may not be specified.     If this parameter is omitted, the result set is not filtered by target actions, and the corresponding target actions field and details are not returned in the response.    
   * @return targetActions
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating target price actions discussed in the document.   The supported target actions:   - Decrease - Lowers the previously stated target price for a security.   - Increase - Raises the previously stated target price for a security.   - Reiterate - Confirms the existing target price without change.   - Update - Modifies the target price, direction may or may not be specified.     If this parameter is omitted, the result set is not filtered by target actions, and the corresponding target actions field and details are not returned in the response.    ")
  @JsonProperty(JSON_PROPERTY_TARGET_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<TargetActionsEnum> getTargetActions() {
    return targetActions;
  }


  @JsonProperty(JSON_PROPERTY_TARGET_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTargetActions(java.util.Set<TargetActionsEnum> targetActions) {
    this.targetActions = targetActions;
  }


  public SearchRequestBody weightingActions(java.util.Set<WeightingActionsEnum> weightingActions) {
    this.weightingActions = weightingActions;
    return this;
  }

  public SearchRequestBody addWeightingActionsItem(WeightingActionsEnum weightingActionsItem) {
    if (this.weightingActions == null) {
      this.weightingActions = new java.util.LinkedHashSet<>();
    }
    this.weightingActions.add(weightingActionsItem);
    return this;
  }

   /**
   * One or more codes indicating weighting actions discussed in the document.   The supported weighting actions:   - Decrease - Lowers the portfolio weighting or exposure to a security or sector.   - Increase - Raises the portfolio weighting or exposure to a security or sector.   - Reiterate - Maintains the current weighting recommendation without change.   - Update - Adjusts the weighting, potentially reflecting a revised strategy or allocation.     If this parameter is omitted, the result set is not filtered by weighting actions, and the corresponding weighting actions field and details are not returned in the response.  
   * @return weightingActions
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "One or more codes indicating weighting actions discussed in the document.   The supported weighting actions:   - Decrease - Lowers the portfolio weighting or exposure to a security or sector.   - Increase - Raises the portfolio weighting or exposure to a security or sector.   - Reiterate - Maintains the current weighting recommendation without change.   - Update - Adjusts the weighting, potentially reflecting a revised strategy or allocation.     If this parameter is omitted, the result set is not filtered by weighting actions, and the corresponding weighting actions field and details are not returned in the response.  ")
  @JsonProperty(JSON_PROPERTY_WEIGHTING_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<WeightingActionsEnum> getWeightingActions() {
    return weightingActions;
  }


  @JsonProperty(JSON_PROPERTY_WEIGHTING_ACTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWeightingActions(java.util.Set<WeightingActionsEnum> weightingActions) {
    this.weightingActions = weightingActions;
  }


  /**
   * Return true if this SearchRequestBody object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchRequestBody searchRequestBody = (SearchRequestBody) o;
    return Objects.equals(this.ids, searchRequestBody.ids) &&
        Objects.equals(this.startDate, searchRequestBody.startDate) &&
        Objects.equals(this.endDate, searchRequestBody.endDate) &&
        Objects.equals(this.startDateRelative, searchRequestBody.startDateRelative) &&
        Objects.equals(this.endDateRelative, searchRequestBody.endDateRelative) &&
        Objects.equals(this.sources, searchRequestBody.sources) &&
        Objects.equals(this.timezone, searchRequestBody.timezone) &&
        Objects.equals(this.categories, searchRequestBody.categories) &&
        Objects.equals(this.primaryId, searchRequestBody.primaryId) &&
        Objects.equals(this.searchText, searchRequestBody.searchText) &&
        Objects.equals(this.contributorId, searchRequestBody.contributorId) &&
        Objects.equals(this.analystId, searchRequestBody.analystId) &&
        Objects.equals(this.reportFoci, searchRequestBody.reportFoci) &&
        Objects.equals(this.securityTypes, searchRequestBody.securityTypes) &&
        Objects.equals(this.assetTypes, searchRequestBody.assetTypes) &&
        Objects.equals(this.assetClasses, searchRequestBody.assetClasses) &&
        Objects.equals(this.coverageActions, searchRequestBody.coverageActions) &&
        Objects.equals(this.compilationIndicators, searchRequestBody.compilationIndicators) &&
        Objects.equals(this.disciplines, searchRequestBody.disciplines) &&
        Objects.equals(this.issuerTypes, searchRequestBody.issuerTypes) &&
        Objects.equals(this.periodicities, searchRequestBody.periodicities) &&
        Objects.equals(this.purposes, searchRequestBody.purposes) &&
        Objects.equals(this.ratingActions, searchRequestBody.ratingActions) &&
        Objects.equals(this.researchApproaches, searchRequestBody.researchApproaches) &&
        Objects.equals(this.targetActions, searchRequestBody.targetActions) &&
        Objects.equals(this.weightingActions, searchRequestBody.weightingActions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ids, startDate, endDate, startDateRelative, endDateRelative, sources, timezone, categories, primaryId, searchText, contributorId, analystId, reportFoci, securityTypes, assetTypes, assetClasses, coverageActions, compilationIndicators, disciplines, issuerTypes, periodicities, purposes, ratingActions, researchApproaches, targetActions, weightingActions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchRequestBody {\n");
    sb.append("    ids: ").append(toIndentedString(ids)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    startDateRelative: ").append(toIndentedString(startDateRelative)).append("\n");
    sb.append("    endDateRelative: ").append(toIndentedString(endDateRelative)).append("\n");
    sb.append("    sources: ").append(toIndentedString(sources)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    categories: ").append(toIndentedString(categories)).append("\n");
    sb.append("    primaryId: ").append(toIndentedString(primaryId)).append("\n");
    sb.append("    searchText: ").append(toIndentedString(searchText)).append("\n");
    sb.append("    contributorId: ").append(toIndentedString(contributorId)).append("\n");
    sb.append("    analystId: ").append(toIndentedString(analystId)).append("\n");
    sb.append("    reportFoci: ").append(toIndentedString(reportFoci)).append("\n");
    sb.append("    securityTypes: ").append(toIndentedString(securityTypes)).append("\n");
    sb.append("    assetTypes: ").append(toIndentedString(assetTypes)).append("\n");
    sb.append("    assetClasses: ").append(toIndentedString(assetClasses)).append("\n");
    sb.append("    coverageActions: ").append(toIndentedString(coverageActions)).append("\n");
    sb.append("    compilationIndicators: ").append(toIndentedString(compilationIndicators)).append("\n");
    sb.append("    disciplines: ").append(toIndentedString(disciplines)).append("\n");
    sb.append("    issuerTypes: ").append(toIndentedString(issuerTypes)).append("\n");
    sb.append("    periodicities: ").append(toIndentedString(periodicities)).append("\n");
    sb.append("    purposes: ").append(toIndentedString(purposes)).append("\n");
    sb.append("    ratingActions: ").append(toIndentedString(ratingActions)).append("\n");
    sb.append("    researchApproaches: ").append(toIndentedString(researchApproaches)).append("\n");
    sb.append("    targetActions: ").append(toIndentedString(targetActions)).append("\n");
    sb.append("    weightingActions: ").append(toIndentedString(weightingActions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

