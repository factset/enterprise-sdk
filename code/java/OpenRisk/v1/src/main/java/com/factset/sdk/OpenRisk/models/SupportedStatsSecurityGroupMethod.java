/*
 * Open:Risk API
 * Service to calculate parametric linear risk statistics and generate risk model asset identifier mappings.
 *
 * The version of the OpenAPI document: 1.24.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.OpenRisk.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.OpenRisk.JSON;


/**
 * If present, describes the calculations specified in common by all of the &#39;derived&#39; stats across all supported &#39;levels&#39; containing &#39;SecurityGroup&#39; in the name. If not present, security group calculations are not available for these stats.
 */
@ApiModel(description = "If present, describes the calculations specified in common by all of the 'derived' stats across all supported 'levels' containing 'SecurityGroup' in the name. If not present, security group calculations are not available for these stats.")
@JsonPropertyOrder({
  SupportedStatsSecurityGroupMethod.JSON_PROPERTY_NAME,
  SupportedStatsSecurityGroupMethod.JSON_PROPERTY_WEIGHTS,
  SupportedStatsSecurityGroupMethod.JSON_PROPERTY_WEIGHTING,
  SupportedStatsSecurityGroupMethod.JSON_PROPERTY_SQRT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class SupportedStatsSecurityGroupMethod implements Serializable {
  private static final long serialVersionUID = 1L;

  /**
   * Indicates the algorithm used to compute each security group&#39;s value from the  risk statistic values of its member securities. &#39;Sum&#39; takes the sum of all members&#39; values. The weighted average methods indicate &#39;weights&#39; and &#39;weighting&#39;. &#39;WeightedAverage&#39; weights each group&#39;s members&#39; statistic values and takes their average. &#39;WeightedNormalizedAverage&#39; normalizes the corresponding weights belonging within each group, weights each group&#39;s members&#39; statistic values, then takes the average. &#39;WeightedNormalizedAverageFill&#39; normalizes the corresponding weights belonging within each group or applies equal weighting for groups with zero net weight, weights each group&#39;s members&#39; statistic values, then takes the average. &#39;StatSpecific&#39; indicates unique calculations for the supported security group levels (inquire for more information).
   */
  public enum NameEnum {
    STATSPECIFIC("StatSpecific"),
    
    SUM("Sum"),
    
    WEIGHTEDAVERAGE("WeightedAverage"),
    
    WEIGHTEDNORMALIZEDAVERAGE("WeightedNormalizedAverage"),
    
    WEIGHTEDNORMALIZEDAVERAGEFILL("WeightedNormalizedAverageFill");

    private String value;

    NameEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static NameEnum fromValue(String value) {
      for (NameEnum b : NameEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_NAME = "name";
  private NameEnum name;

  /**
   * Indicates the weights stat used to weight the security groups, applicable to weighted average group methods only.
   */
  public enum WeightsEnum {
    PORTFOLIOWEIGHTS("PortfolioWeights"),
    
    BENCHMARKWEIGHTS("BenchmarkWeights"),
    
    ACTIVEWEIGHTS("ActiveWeights"),
    
    MARKETWEIGHTS("MarketWeights");

    private String value;

    WeightsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WeightsEnum fromValue(String value) {
      for (WeightsEnum b : WeightsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_WEIGHTS = "weights";
  private WeightsEnum weights;

  /**
   * Indicates the weighting method used when allocating a net-weight position of risk statistics to multiple lots. This is relevant when a portfolio contains multiple lots with different signs such as long/short. For example, the case where a net-weight position is a positive risk contributor and a portfolio contains long and short positions. If this is &#39;AbsoluteValue&#39;, both long/short positions will have positive risk contribution, while &#39;ActualValue&#39; assigns positive risk contribution to a long position and negative risk contribution to a short position. Applicable to weighted average group methods only.
   */
  public enum WeightingEnum {
    ABSOLUTEVALUE("AbsoluteValue"),
    
    ACTUALVALUE("ActualValue");

    private String value;

    WeightingEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static WeightingEnum fromValue(String value) {
      for (WeightingEnum b : WeightingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_WEIGHTING = "weighting";
  private WeightingEnum weighting;

  public static final String JSON_PROPERTY_SQRT = "sqrt";
  private Boolean sqrt;

  public SupportedStatsSecurityGroupMethod() { 
  }

  @JsonCreator
  public SupportedStatsSecurityGroupMethod(
    @JsonProperty(value=JSON_PROPERTY_NAME, required=true) NameEnum name, 
    @JsonProperty(value=JSON_PROPERTY_SQRT, required=true) Boolean sqrt
  ) {
    this();
    this.name = name;
    this.sqrt = sqrt;
  }

  public SupportedStatsSecurityGroupMethod name(NameEnum name) {
    this.name = name;
    return this;
  }

   /**
   * Indicates the algorithm used to compute each security group&#39;s value from the  risk statistic values of its member securities. &#39;Sum&#39; takes the sum of all members&#39; values. The weighted average methods indicate &#39;weights&#39; and &#39;weighting&#39;. &#39;WeightedAverage&#39; weights each group&#39;s members&#39; statistic values and takes their average. &#39;WeightedNormalizedAverage&#39; normalizes the corresponding weights belonging within each group, weights each group&#39;s members&#39; statistic values, then takes the average. &#39;WeightedNormalizedAverageFill&#39; normalizes the corresponding weights belonging within each group or applies equal weighting for groups with zero net weight, weights each group&#39;s members&#39; statistic values, then takes the average. &#39;StatSpecific&#39; indicates unique calculations for the supported security group levels (inquire for more information).
   * @return name
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates the algorithm used to compute each security group's value from the  risk statistic values of its member securities. 'Sum' takes the sum of all members' values. The weighted average methods indicate 'weights' and 'weighting'. 'WeightedAverage' weights each group's members' statistic values and takes their average. 'WeightedNormalizedAverage' normalizes the corresponding weights belonging within each group, weights each group's members' statistic values, then takes the average. 'WeightedNormalizedAverageFill' normalizes the corresponding weights belonging within each group or applies equal weighting for groups with zero net weight, weights each group's members' statistic values, then takes the average. 'StatSpecific' indicates unique calculations for the supported security group levels (inquire for more information).")
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public NameEnum getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(NameEnum name) {
    this.name = name;
  }


  public SupportedStatsSecurityGroupMethod weights(WeightsEnum weights) {
    this.weights = weights;
    return this;
  }

   /**
   * Indicates the weights stat used to weight the security groups, applicable to weighted average group methods only.
   * @return weights
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates the weights stat used to weight the security groups, applicable to weighted average group methods only.")
  @JsonProperty(JSON_PROPERTY_WEIGHTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public WeightsEnum getWeights() {
    return weights;
  }


  @JsonProperty(JSON_PROPERTY_WEIGHTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWeights(WeightsEnum weights) {
    this.weights = weights;
  }


  public SupportedStatsSecurityGroupMethod weighting(WeightingEnum weighting) {
    this.weighting = weighting;
    return this;
  }

   /**
   * Indicates the weighting method used when allocating a net-weight position of risk statistics to multiple lots. This is relevant when a portfolio contains multiple lots with different signs such as long/short. For example, the case where a net-weight position is a positive risk contributor and a portfolio contains long and short positions. If this is &#39;AbsoluteValue&#39;, both long/short positions will have positive risk contribution, while &#39;ActualValue&#39; assigns positive risk contribution to a long position and negative risk contribution to a short position. Applicable to weighted average group methods only.
   * @return weighting
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates the weighting method used when allocating a net-weight position of risk statistics to multiple lots. This is relevant when a portfolio contains multiple lots with different signs such as long/short. For example, the case where a net-weight position is a positive risk contributor and a portfolio contains long and short positions. If this is 'AbsoluteValue', both long/short positions will have positive risk contribution, while 'ActualValue' assigns positive risk contribution to a long position and negative risk contribution to a short position. Applicable to weighted average group methods only.")
  @JsonProperty(JSON_PROPERTY_WEIGHTING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public WeightingEnum getWeighting() {
    return weighting;
  }


  @JsonProperty(JSON_PROPERTY_WEIGHTING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWeighting(WeightingEnum weighting) {
    this.weighting = weighting;
  }


  public SupportedStatsSecurityGroupMethod sqrt(Boolean sqrt) {
    this.sqrt = sqrt;
    return this;
  }

   /**
   * Indicates whether the square root of each security group&#39;s value is taken (or not) as the final step of the calculation after the indicated algorithm to produce the result.
   * @return sqrt
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates whether the square root of each security group's value is taken (or not) as the final step of the calculation after the indicated algorithm to produce the result.")
  @JsonProperty(JSON_PROPERTY_SQRT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getSqrt() {
    return sqrt;
  }


  @JsonProperty(JSON_PROPERTY_SQRT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSqrt(Boolean sqrt) {
    this.sqrt = sqrt;
  }


  /**
   * Return true if this SupportedStats_securityGroupMethod object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SupportedStatsSecurityGroupMethod supportedStatsSecurityGroupMethod = (SupportedStatsSecurityGroupMethod) o;
    return Objects.equals(this.name, supportedStatsSecurityGroupMethod.name) &&
        Objects.equals(this.weights, supportedStatsSecurityGroupMethod.weights) &&
        Objects.equals(this.weighting, supportedStatsSecurityGroupMethod.weighting) &&
        Objects.equals(this.sqrt, supportedStatsSecurityGroupMethod.sqrt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, weights, weighting, sqrt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SupportedStatsSecurityGroupMethod {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    weights: ").append(toIndentedString(weights)).append("\n");
    sb.append("    weighting: ").append(toIndentedString(weighting)).append("\n");
    sb.append("    sqrt: ").append(toIndentedString(sqrt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

