/*
 * Open:Risk API
 * Service to calculate parametric linear risk statistics and generate risk model asset identifier mappings.
 *
 * The version of the OpenAPI document: 1.26.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.OpenRisk.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.factset.sdk.OpenRisk.models.StatCalculationLevel;
import com.factset.sdk.OpenRisk.models.SupportedStatDetailsSecurityGroupMethod;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.OpenRisk.JSON;


/**
 * Details on support and/or requirement for certain name-settings statistics options (such as: correlated specific risk, covariance isolation method, etc.), derived stats, available levels, security group calculation methodology, and multi-lot security allocation. When &#39;securityGroupMethod&#39; is &#39;statSpecific&#39;, please refer to the risk statistics documentation service or inquire for more information.
 */
@ApiModel(description = "Details on support and/or requirement for certain name-settings statistics options (such as: correlated specific risk, covariance isolation method, etc.), derived stats, available levels, security group calculation methodology, and multi-lot security allocation. When 'securityGroupMethod' is 'statSpecific', please refer to the risk statistics documentation service or inquire for more information.")
@JsonPropertyOrder({
  SupportedStatDetails.JSON_PROPERTY_CORRELATED_SPECIFIC_RISK,
  SupportedStatDetails.JSON_PROPERTY_COVARIANCE_TIMES_TWO,
  SupportedStatDetails.JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK,
  SupportedStatDetails.JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO,
  SupportedStatDetails.JSON_PROPERTY_DERIVED,
  SupportedStatDetails.JSON_PROPERTY_SUPPORTED_LEVELS,
  SupportedStatDetails.JSON_PROPERTY_SECURITY_GROUP_METHOD,
  SupportedStatDetails.JSON_PROPERTY_SECURITY_LOT_ALLOCATION
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")

public class SupportedStatDetails implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_CORRELATED_SPECIFIC_RISK = "correlatedSpecificRisk";
  private Boolean correlatedSpecificRisk;

  public static final String JSON_PROPERTY_COVARIANCE_TIMES_TWO = "covarianceTimesTwo";
  private Boolean covarianceTimesTwo;

  public static final String JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK = "requiresCorrelatedSpecificRisk";
  private Boolean requiresCorrelatedSpecificRisk;

  public static final String JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO = "requiresCovarianceTimesTwo";
  private Boolean requiresCovarianceTimesTwo;

  public static final String JSON_PROPERTY_DERIVED = "derived";
  private java.util.List<String> derived = new java.util.ArrayList<>();

  public static final String JSON_PROPERTY_SUPPORTED_LEVELS = "supportedLevels";
  private java.util.List<StatCalculationLevel> supportedLevels = new java.util.ArrayList<>();

  public static final String JSON_PROPERTY_SECURITY_GROUP_METHOD = "securityGroupMethod";
  private SupportedStatDetailsSecurityGroupMethod securityGroupMethod;

  /**
   * Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. &#39;FillAll&#39; indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with &#39;weighting&#39; method specified in &#39;securityGroupMethod&#39;. For example, if this is &#39;ActiveWeights&#39; and &#39;weighting&#39; is &#39;AbsoluteValue&#39;, a net position value is allocated to multiple lots based off of absolute active weights distribution.
   */
  public enum SecurityLotAllocationEnum {
    PORTFOLIOWEIGHTS("PortfolioWeights"),
    
    BENCHMARKWEIGHTS("BenchmarkWeights"),
    
    ACTIVEWEIGHTS("ActiveWeights"),
    
    MARKETWEIGHTS("MarketWeights"),
    
    FILLALL("FillAll");

    private String value;

    SecurityLotAllocationEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SecurityLotAllocationEnum fromValue(String value) {
      for (SecurityLotAllocationEnum b : SecurityLotAllocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_SECURITY_LOT_ALLOCATION = "securityLotAllocation";
  private SecurityLotAllocationEnum securityLotAllocation;

  public SupportedStatDetails() { 
  }

  @JsonCreator
  public SupportedStatDetails(
    @JsonProperty(value=JSON_PROPERTY_CORRELATED_SPECIFIC_RISK, required=true) Boolean correlatedSpecificRisk, 
    @JsonProperty(value=JSON_PROPERTY_COVARIANCE_TIMES_TWO, required=true) Boolean covarianceTimesTwo, 
    @JsonProperty(value=JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK, required=true) Boolean requiresCorrelatedSpecificRisk, 
    @JsonProperty(value=JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO, required=true) Boolean requiresCovarianceTimesTwo, 
    @JsonProperty(value=JSON_PROPERTY_DERIVED, required=true) java.util.List<String> derived, 
    @JsonProperty(value=JSON_PROPERTY_SUPPORTED_LEVELS, required=true) java.util.List<StatCalculationLevel> supportedLevels
  ) {
    this();
    this.correlatedSpecificRisk = correlatedSpecificRisk;
    this.covarianceTimesTwo = covarianceTimesTwo;
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
    this.derived = derived;
    this.supportedLevels = supportedLevels;
  }

  public SupportedStatDetails correlatedSpecificRisk(Boolean correlatedSpecificRisk) {
    this.correlatedSpecificRisk = correlatedSpecificRisk;
    return this;
  }

   /**
   * Indicates support for correlated specific risk (CSR) calculation setting if true, and false if the setting is prohibited.
   * @return correlatedSpecificRisk
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates support for correlated specific risk (CSR) calculation setting if true, and false if the setting is prohibited.")
  @JsonProperty(JSON_PROPERTY_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getCorrelatedSpecificRisk() {
    return correlatedSpecificRisk;
  }


  @JsonProperty(JSON_PROPERTY_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCorrelatedSpecificRisk(Boolean correlatedSpecificRisk) {
    this.correlatedSpecificRisk = correlatedSpecificRisk;
  }


  public SupportedStatDetails covarianceTimesTwo(Boolean covarianceTimesTwo) {
    this.covarianceTimesTwo = covarianceTimesTwo;
    return this;
  }

   /**
   * Indicates support for covariance times two (Cov*2) calculation setting if true, and false if the setting is prohibited.
   * @return covarianceTimesTwo
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates support for covariance times two (Cov*2) calculation setting if true, and false if the setting is prohibited.")
  @JsonProperty(JSON_PROPERTY_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getCovarianceTimesTwo() {
    return covarianceTimesTwo;
  }


  @JsonProperty(JSON_PROPERTY_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCovarianceTimesTwo(Boolean covarianceTimesTwo) {
    this.covarianceTimesTwo = covarianceTimesTwo;
  }


  public SupportedStatDetails requiresCorrelatedSpecificRisk(Boolean requiresCorrelatedSpecificRisk) {
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
    return this;
  }

   /**
   * Indicates correlated specific risk (CSR) calculation setting is mandatory for the stat, if true.
   * @return requiresCorrelatedSpecificRisk
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates correlated specific risk (CSR) calculation setting is mandatory for the stat, if true.")
  @JsonProperty(JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getRequiresCorrelatedSpecificRisk() {
    return requiresCorrelatedSpecificRisk;
  }


  @JsonProperty(JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRequiresCorrelatedSpecificRisk(Boolean requiresCorrelatedSpecificRisk) {
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
  }


  public SupportedStatDetails requiresCovarianceTimesTwo(Boolean requiresCovarianceTimesTwo) {
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
    return this;
  }

   /**
   * Indicates covariance times two (Cov*2) calculation setting is mandatory for the stat, if true.
   * @return requiresCovarianceTimesTwo
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates covariance times two (Cov*2) calculation setting is mandatory for the stat, if true.")
  @JsonProperty(JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getRequiresCovarianceTimesTwo() {
    return requiresCovarianceTimesTwo;
  }


  @JsonProperty(JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRequiresCovarianceTimesTwo(Boolean requiresCovarianceTimesTwo) {
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
  }


  public SupportedStatDetails derived(java.util.List<String> derived) {
    this.derived = derived;
    return this;
  }

  public SupportedStatDetails addDerivedItem(String derivedItem) {
    this.derived.add(derivedItem);
    return this;
  }

   /**
   * A list of the base stat and all possible derived stats which are currently supported by the service.
   * @return derived
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of the base stat and all possible derived stats which are currently supported by the service.")
  @JsonProperty(JSON_PROPERTY_DERIVED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public java.util.List<String> getDerived() {
    return derived;
  }


  @JsonProperty(JSON_PROPERTY_DERIVED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDerived(java.util.List<String> derived) {
    this.derived = derived;
  }


  public SupportedStatDetails supportedLevels(java.util.List<StatCalculationLevel> supportedLevels) {
    this.supportedLevels = supportedLevels;
    return this;
  }

  public SupportedStatDetails addSupportedLevelsItem(StatCalculationLevel supportedLevelsItem) {
    this.supportedLevels.add(supportedLevelsItem);
    return this;
  }

   /**
   * Indicates the calculation levels that are supported by the base stat and all derived stats. Unless it is present, a given calculation level is not supported.
   * @return supportedLevels
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Indicates the calculation levels that are supported by the base stat and all derived stats. Unless it is present, a given calculation level is not supported.")
  @JsonProperty(JSON_PROPERTY_SUPPORTED_LEVELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public java.util.List<StatCalculationLevel> getSupportedLevels() {
    return supportedLevels;
  }


  @JsonProperty(JSON_PROPERTY_SUPPORTED_LEVELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSupportedLevels(java.util.List<StatCalculationLevel> supportedLevels) {
    this.supportedLevels = supportedLevels;
  }


  public SupportedStatDetails securityGroupMethod(SupportedStatDetailsSecurityGroupMethod securityGroupMethod) {
    this.securityGroupMethod = securityGroupMethod;
    return this;
  }

   /**
   * Get securityGroupMethod
   * @return securityGroupMethod
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_SECURITY_GROUP_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SupportedStatDetailsSecurityGroupMethod getSecurityGroupMethod() {
    return securityGroupMethod;
  }


  @JsonProperty(JSON_PROPERTY_SECURITY_GROUP_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSecurityGroupMethod(SupportedStatDetailsSecurityGroupMethod securityGroupMethod) {
    this.securityGroupMethod = securityGroupMethod;
  }


  public SupportedStatDetails securityLotAllocation(SecurityLotAllocationEnum securityLotAllocation) {
    this.securityLotAllocation = securityLotAllocation;
    return this;
  }

   /**
   * Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. &#39;FillAll&#39; indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with &#39;weighting&#39; method specified in &#39;securityGroupMethod&#39;. For example, if this is &#39;ActiveWeights&#39; and &#39;weighting&#39; is &#39;AbsoluteValue&#39;, a net position value is allocated to multiple lots based off of absolute active weights distribution.
   * @return securityLotAllocation
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. 'FillAll' indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with 'weighting' method specified in 'securityGroupMethod'. For example, if this is 'ActiveWeights' and 'weighting' is 'AbsoluteValue', a net position value is allocated to multiple lots based off of absolute active weights distribution.")
  @JsonProperty(JSON_PROPERTY_SECURITY_LOT_ALLOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SecurityLotAllocationEnum getSecurityLotAllocation() {
    return securityLotAllocation;
  }


  @JsonProperty(JSON_PROPERTY_SECURITY_LOT_ALLOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSecurityLotAllocation(SecurityLotAllocationEnum securityLotAllocation) {
    this.securityLotAllocation = securityLotAllocation;
  }


  /**
   * Return true if this SupportedStatDetails object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SupportedStatDetails supportedStatDetails = (SupportedStatDetails) o;
    return Objects.equals(this.correlatedSpecificRisk, supportedStatDetails.correlatedSpecificRisk) &&
        Objects.equals(this.covarianceTimesTwo, supportedStatDetails.covarianceTimesTwo) &&
        Objects.equals(this.requiresCorrelatedSpecificRisk, supportedStatDetails.requiresCorrelatedSpecificRisk) &&
        Objects.equals(this.requiresCovarianceTimesTwo, supportedStatDetails.requiresCovarianceTimesTwo) &&
        Objects.equals(this.derived, supportedStatDetails.derived) &&
        Objects.equals(this.supportedLevels, supportedStatDetails.supportedLevels) &&
        Objects.equals(this.securityGroupMethod, supportedStatDetails.securityGroupMethod) &&
        Objects.equals(this.securityLotAllocation, supportedStatDetails.securityLotAllocation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(correlatedSpecificRisk, covarianceTimesTwo, requiresCorrelatedSpecificRisk, requiresCovarianceTimesTwo, derived, supportedLevels, securityGroupMethod, securityLotAllocation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SupportedStatDetails {\n");
    sb.append("    correlatedSpecificRisk: ").append(toIndentedString(correlatedSpecificRisk)).append("\n");
    sb.append("    covarianceTimesTwo: ").append(toIndentedString(covarianceTimesTwo)).append("\n");
    sb.append("    requiresCorrelatedSpecificRisk: ").append(toIndentedString(requiresCorrelatedSpecificRisk)).append("\n");
    sb.append("    requiresCovarianceTimesTwo: ").append(toIndentedString(requiresCovarianceTimesTwo)).append("\n");
    sb.append("    derived: ").append(toIndentedString(derived)).append("\n");
    sb.append("    supportedLevels: ").append(toIndentedString(supportedLevels)).append("\n");
    sb.append("    securityGroupMethod: ").append(toIndentedString(securityGroupMethod)).append("\n");
    sb.append("    securityLotAllocation: ").append(toIndentedString(securityLotAllocation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

