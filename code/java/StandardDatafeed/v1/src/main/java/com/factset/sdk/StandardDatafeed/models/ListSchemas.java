/*
 * SDF Download API
 * The Standard DataFeed (SDF) Download API provides an alternative method for users to request and retrieve SDF packages (schemas & bundles). This service is not a direct replacement and does not have 100% feature parity with the Loader Application. This API provides an alternative for users who are unable to utilize the Loader application due to following reasons:   - Inability to install 3rd party executables due to Corporate Security policies     - Inability to utilize the Loader application due to limitations or restrictions with the environment used to consume Standard Datafeed   - Clients who are utilizing existing delivery method like FTP, who may want to use a more secured & modern solution     This API allows users to retrieve maximum of latest 30 days of data     Additional parameters are available to filter requests to get the exact files users are looking for.    QFL data is delivered through Content API & Bulk Data API (SDF API)  - Content API : Provides direct access to FactSet-hosted QFL data.  Suitable for interactive, ad hoc QFL requests.  Constraints on large extracts.  Costs are based on consumption, i.e. more calls can result in more costs.  - Bulk Data API : Provides access to download locations of zip files for client download. Suitable for production processes within a client environment. Cost is based on the use case and fixed unless scope changes (same as other SDFs).
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: teammustang@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.StandardDatafeed.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.factset.sdk.StandardDatafeed.models.SchemaDetails;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.StandardDatafeed.JSON;


import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.Response;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.math.BigDecimal;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.factset.sdk.StandardDatafeed.JSON;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")

@JsonDeserialize(using=ListSchemas.ListSchemasDeserializer.class)
@JsonSerialize(using = ListSchemas.ListSchemasSerializer.class)
public class ListSchemas extends AbstractOpenApiSchema implements Serializable {
    private static final Logger log = Logger.getLogger(ListSchemas.class.getName());

    public static class ListSchemasSerializer extends StdSerializer<ListSchemas> {
        public ListSchemasSerializer(Class<ListSchemas> t) {
            super(t);
        }

        public ListSchemasSerializer() {
            this(null);
        }

        @Override
        public void serialize(ListSchemas value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class ListSchemasDeserializer extends StdDeserializer<ListSchemas> {
        public ListSchemasDeserializer() {
            this(ListSchemas.class);
        }

        public ListSchemasDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public ListSchemas deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();

            Object deserialized = null;
            // deserialize java.util.Map<String, java.util.List<String>>
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<java.util.Map<String, java.util.List<String>>>(){});
                ListSchemas ret = new ListSchemas();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'ListSchemas'", e);
            }

            // deserialize SchemaDetails
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<SchemaDetails>(){});
                ListSchemas ret = new ListSchemas();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'ListSchemas'", e);
            }

            throw new IOException(String.format("Failed deserialization for ListSchemas: no match found"));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public ListSchemas getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "ListSchemas cannot be null");
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public ListSchemas() {
        super("anyOf", Boolean.FALSE);
    }

    public ListSchemas(SchemaDetails o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ListSchemas(java.util.Map<String, java.util.List<String>> o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("SchemaDetails", new GenericType<SchemaDetails>() {
        });
        schemas.put("java.util.Map<String, java.util.List<String>>", new GenericType<java.util.Map<String, java.util.List<String>>>() {
        });
        JSON.registerDescendants(ListSchemas.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return ListSchemas.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * SchemaDetails, java.util.Map<String, java.util.List<String>>
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, anyOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(java.util.Map.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SchemaDetails.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be SchemaDetails, java.util.Map<String, java.util.List<String>>");
    }

    /**
     * Get the actual instance, which can be the following:
     * SchemaDetails, java.util.Map<String, java.util.List<String>>
     *
     * @return The actual instance (SchemaDetails, java.util.Map<String, java.util.List<String>>)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `java.util.Map<String, java.util.List<String>>`.
     * If the actual instance is not `java.util.Map<String, java.util.List<String>>`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `java.util.Map<String, java.util.List<String>>`
     * @throws ClassCastException if the instance is not `java.util.Map<String, java.util.List<String>>`
     */
    public java.util.Map<String, java.util.List<String>> getAnyOf0() throws ClassCastException {
        return (java.util.Map<String, java.util.List<String>>)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SchemaDetails`.
     * If the actual instance is not `SchemaDetails`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SchemaDetails`
     * @throws ClassCastException if the instance is not `SchemaDetails`
     */
    public SchemaDetails getSchemaDetails() throws ClassCastException {
        return (SchemaDetails)super.getActualInstance();
    }

}

