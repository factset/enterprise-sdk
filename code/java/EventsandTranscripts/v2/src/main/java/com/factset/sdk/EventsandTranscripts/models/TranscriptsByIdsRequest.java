/*
 * Events and Transcripts API
 * <p>The Calendar Events API provides access to FactSetâ€™s Event Calendar data alongside business logic that allows users to replicate views and functionality consistent with the experience provided by the Workstation. This API provides the ability to pull Event Calendar data based on specific filters.</p> <p>Events Audio API provides access to historical as well as the latest audio recordings of various company events covered by FactSet. The events include, but are not limited to: earnings calls, conferences, and investor days. This API also provides relevant metadata such as timestamps and identifiers around each audio file.</p> <p>The  Near Real-time Transcripts API enables access to Near Real-time Transcripts provided by CallStreet to time-sensitive clients. This API also provides the relevant speaker metadata along with their confidence scores. This data caters to quant clients interested in building machine learning models. Clients can leverage this API to perform sentiment analysis through natural language processing or machine learning. It can also be used to complement analysis using FactSet's transcripts service.</p> <p>Transcripts API provides conference call transcripts for companies' publicly held conference calls and a wealth of information regarding upcoming corporate events, such as conference call date and time, phone number and password, type of conference call, and important company investor relations contact information.</p> 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.EventsandTranscripts.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.time.LocalDate;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.EventsandTranscripts.JSON;


/**
 * Search criteria for transcripts based on various IDs and categories.
 */
@ApiModel(description = "Search criteria for transcripts based on various IDs and categories.")
@JsonPropertyOrder({
  TranscriptsByIdsRequest.JSON_PROPERTY_PRIMARY_ID,
  TranscriptsByIdsRequest.JSON_PROPERTY_IDS,
  TranscriptsByIdsRequest.JSON_PROPERTY_REPORT_IDS,
  TranscriptsByIdsRequest.JSON_PROPERTY_CATEGORIES,
  TranscriptsByIdsRequest.JSON_PROPERTY_START_DATE,
  TranscriptsByIdsRequest.JSON_PROPERTY_END_DATE,
  TranscriptsByIdsRequest.JSON_PROPERTY_SEARCH_TEXT
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")

public class TranscriptsByIdsRequest implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_PRIMARY_ID = "primaryId";
  private Boolean primaryId = false;

  public static final String JSON_PROPERTY_IDS = "ids";
  private java.util.List<String> ids = new java.util.ArrayList<>();

  public static final String JSON_PROPERTY_REPORT_IDS = "reportIds";
  private java.util.List<String> reportIds = null;

  public static final String JSON_PROPERTY_CATEGORIES = "categories";
  private java.util.List<String> categories = null;

  public static final String JSON_PROPERTY_START_DATE = "startDate";
  private LocalDate startDate;

  public static final String JSON_PROPERTY_END_DATE = "endDate";
  private LocalDate endDate;

  public static final String JSON_PROPERTY_SEARCH_TEXT = "searchText";
  private String searchText;

  public TranscriptsByIdsRequest() { 
  }

  @JsonCreator
  public TranscriptsByIdsRequest(
    @JsonProperty(value=JSON_PROPERTY_IDS, required=true) java.util.List<String> ids
  ) {
    this();
    this.ids = ids;
  }

  public TranscriptsByIdsRequest primaryId(Boolean primaryId) {
    this.primaryId = primaryId;
    return this;
  }

   /**
   * If true, search only for documents where the provided &#x60;ids&#x60; are the primary identifiers. If false, search for any mention.
   * @return primaryId
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(value = "If true, search only for documents where the provided `ids` are the primary identifiers. If false, search for any mention.")
  @JsonProperty(JSON_PROPERTY_PRIMARY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getPrimaryId() {
    return primaryId;
  }


  @JsonProperty(JSON_PROPERTY_PRIMARY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPrimaryId(Boolean primaryId) {
    this.primaryId = primaryId;
  }


  public TranscriptsByIdsRequest ids(java.util.List<String> ids) {
    this.ids = ids;
    return this;
  }

  public TranscriptsByIdsRequest addIdsItem(String idsItem) {
    this.ids.add(idsItem);
    return this;
  }

   /**
   * Requested symbols or securities. This is a list with a maximum limit of 1000. Each symbol can be a FactSet exchange symbol, CUSIP, SEDOL, ISIN, or Entity ID
   * @return ids
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(example = "[\"MODN-US\",\"OSIS-US\"]", required = true, value = "Requested symbols or securities. This is a list with a maximum limit of 1000. Each symbol can be a FactSet exchange symbol, CUSIP, SEDOL, ISIN, or Entity ID")
  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public java.util.List<String> getIds() {
    return ids;
  }


  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIds(java.util.List<String> ids) {
    this.ids = ids;
  }


  public TranscriptsByIdsRequest reportIds(java.util.List<String> reportIds) {
    this.reportIds = reportIds;
    return this;
  }

  public TranscriptsByIdsRequest addReportIdsItem(String reportIdsItem) {
    if (this.reportIds == null) {
      this.reportIds = new java.util.ArrayList<>();
    }
    this.reportIds.add(reportIdsItem);
    return this;
  }

   /**
   * List of report IDs (max 1000).
   * @return reportIds
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[\"102034\",\"102035\"]", value = "List of report IDs (max 1000).")
  @JsonProperty(JSON_PROPERTY_REPORT_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<String> getReportIds() {
    return reportIds;
  }


  @JsonProperty(JSON_PROPERTY_REPORT_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReportIds(java.util.List<String> reportIds) {
    this.reportIds = reportIds;
  }


  public TranscriptsByIdsRequest categories(java.util.List<String> categories) {
    this.categories = categories;
    return this;
  }

  public TranscriptsByIdsRequest addCategoriesItem(String categoriesItem) {
    if (this.categories == null) {
      this.categories = new java.util.ArrayList<>();
    }
    this.categories.add(categoriesItem);
    return this;
  }

   /**
   * List of category codes (country, industry, subject). Use &#x60;/meta/categories&#x60; endpoint. Default is all.
   * @return categories
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "[\"CN:US\",\"LN:EN\"]", value = "List of category codes (country, industry, subject). Use `/meta/categories` endpoint. Default is all.")
  @JsonProperty(JSON_PROPERTY_CATEGORIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<String> getCategories() {
    return categories;
  }


  @JsonProperty(JSON_PROPERTY_CATEGORIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCategories(java.util.List<String> categories) {
    this.categories = categories;
  }


  public TranscriptsByIdsRequest startDate(LocalDate startDate) {
    this.startDate = startDate;
    return this;
  }

   /**
   * Start Date (YYYY-MM-DD). 
   * @return startDate
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Fri Dec 22 00:00:00 UTC 2023", value = "Start Date (YYYY-MM-DD). ")
  @JsonProperty(JSON_PROPERTY_START_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public LocalDate getStartDate() {
    return startDate;
  }


  @JsonProperty(JSON_PROPERTY_START_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartDate(LocalDate startDate) {
    this.startDate = startDate;
  }


  public TranscriptsByIdsRequest endDate(LocalDate endDate) {
    this.endDate = endDate;
    return this;
  }

   /**
   * End Date (YYYY-MM-DD). 
   * @return endDate
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "Sat Dec 23 00:00:00 UTC 2023", value = "End Date (YYYY-MM-DD). ")
  @JsonProperty(JSON_PROPERTY_END_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public LocalDate getEndDate() {
    return endDate;
  }


  @JsonProperty(JSON_PROPERTY_END_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEndDate(LocalDate endDate) {
    this.endDate = endDate;
  }


  public TranscriptsByIdsRequest searchText(String searchText) {
    this.searchText = searchText;
    return this;
  }

   /**
   * Text to search for within the transcript document stories.
   * @return searchText
  **/
  @jakarta.annotation.Nullable
  @ApiModelProperty(example = "guidance update", value = "Text to search for within the transcript document stories.")
  @JsonProperty(JSON_PROPERTY_SEARCH_TEXT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSearchText() {
    return searchText;
  }


  @JsonProperty(JSON_PROPERTY_SEARCH_TEXT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSearchText(String searchText) {
    this.searchText = searchText;
  }


  /**
   * Return true if this TranscriptsByIdsRequest object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TranscriptsByIdsRequest transcriptsByIdsRequest = (TranscriptsByIdsRequest) o;
    return Objects.equals(this.primaryId, transcriptsByIdsRequest.primaryId) &&
        Objects.equals(this.ids, transcriptsByIdsRequest.ids) &&
        Objects.equals(this.reportIds, transcriptsByIdsRequest.reportIds) &&
        Objects.equals(this.categories, transcriptsByIdsRequest.categories) &&
        Objects.equals(this.startDate, transcriptsByIdsRequest.startDate) &&
        Objects.equals(this.endDate, transcriptsByIdsRequest.endDate) &&
        Objects.equals(this.searchText, transcriptsByIdsRequest.searchText);
  }

  @Override
  public int hashCode() {
    return Objects.hash(primaryId, ids, reportIds, categories, startDate, endDate, searchText);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TranscriptsByIdsRequest {\n");
    sb.append("    primaryId: ").append(toIndentedString(primaryId)).append("\n");
    sb.append("    ids: ").append(toIndentedString(ids)).append("\n");
    sb.append("    reportIds: ").append(toIndentedString(reportIds)).append("\n");
    sb.append("    categories: ").append(toIndentedString(categories)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    searchText: ").append(toIndentedString(searchText)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

