/*
 * EVENTS AND TRANSCRIPTS API
 *
 * <p>The Calendar Events API provides access to FactSetâ€™s Event Calendar data alongside business logic that allows users to replicate views and functionality consistent with the experience provided by the Workstation. This API provides the ability to pull Event Calendar data based on specific filters.</p> <p>Events Audio API provides access to historical as well as the latest audio recordings of various company events covered by FactSet. The events include, but are not limited to: earnings calls, conferences, and investor days. This API also provides relevant metadata such as timestamps and identifiers around each audio file.</p> <p>The  Near Real-time Transcripts API enables access to Near Real-time Transcripts provided by CallStreet to time-sensitive clients. This API also provides the relevant speaker metadata along with their confidence scores. This data caters to quant clients interested in building machine learning models. Clients can leverage this API to perform sentiment analysis through natural language processing or machine learning. It can also be used to complement analysis using FactSet's transcripts service.</p> <p>Transcripts API provides conference call transcripts for companies' publicly held conference calls and a wealth of information regarding upcoming corporate events, such as conference call date and time, phone number and password, type of conference call, and important company investor relations contact information.</p>  
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using FactSet.SDK.EventsandTranscripts.Client;
using FactSet.SDK.EventsandTranscripts.Model;
using FactSet.SDK.Utils.Authentication;

namespace FactSet.SDK.EventsandTranscripts.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEventsAudioApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.
        /// </summary>
        /// <remarks>
        ///  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <returns>EventsAudioHistory</returns>
        EventsAudioHistory GetDocsDistributorAudioV1HistoryFiles(int year, bool? trimmed = default(bool?));

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.
        /// </summary>
        /// <remarks>
        ///  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <returns>ApiResponse of EventsAudioHistory</returns>
        ApiResponse<EventsAudioHistory> GetDocsDistributorAudioV1HistoryFilesWithHttpInfo(int year, bool? trimmed = default(bool?));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges.
        /// </summary>
        /// <remarks>
        /// Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>EventsAudioDaily</returns>
        EventsAudioDaily GetDocsDistributorAudioV1ListFilesDate(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges.
        /// </summary>
        /// <remarks>
        /// Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>ApiResponse of EventsAudioDaily</returns>
        ApiResponse<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesDateWithHttpInfo(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings corresponding to the provided file name.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <returns>EventsAudioDailyFileName</returns>
        EventsAudioDailyFileName GetDocsDistributorAudioV1ListFilesFileName(string fileName = default(string));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings corresponding to the provided file name.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <returns>ApiResponse of EventsAudioDailyFileName</returns>
        ApiResponse<EventsAudioDailyFileName> GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfo(string fileName = default(string));
        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <returns>EventsAudioDailyIds</returns>
        EventsAudioDailyIds GetDocsDistributorAudioV1ListFilesIds(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?));

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <returns>ApiResponse of EventsAudioDailyIds</returns>
        ApiResponse<EventsAudioDailyIds> GetDocsDistributorAudioV1ListFilesIdsWithHttpInfo(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time.
        /// </summary>
        /// <remarks>
        /// Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>EventsAudioDaily</returns>
        EventsAudioDaily GetDocsDistributorAudioV1ListFilesUploadTime(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time.
        /// </summary>
        /// <remarks>
        /// Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>ApiResponse of EventsAudioDaily</returns>
        ApiResponse<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfo(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEventsAudioApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.
        /// </summary>
        /// <remarks>
        ///  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioHistory</returns>
        System.Threading.Tasks.Task<EventsAudioHistory> GetDocsDistributorAudioV1HistoryFilesAsync(int year, bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.
        /// </summary>
        /// <remarks>
        ///  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioHistory)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsAudioHistory>> GetDocsDistributorAudioV1HistoryFilesWithHttpInfoAsync(int year, bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges.
        /// </summary>
        /// <remarks>
        /// Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDaily</returns>
        System.Threading.Tasks.Task<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesDateAsync(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges.
        /// </summary>
        /// <remarks>
        /// Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDaily)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsAudioDaily>> GetDocsDistributorAudioV1ListFilesDateWithHttpInfoAsync(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings corresponding to the provided file name.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDailyFileName</returns>
        System.Threading.Tasks.Task<EventsAudioDailyFileName> GetDocsDistributorAudioV1ListFilesFileNameAsync(string fileName = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings corresponding to the provided file name.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDailyFileName)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsAudioDailyFileName>> GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfoAsync(string fileName = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDailyIds</returns>
        System.Threading.Tasks.Task<EventsAudioDailyIds> GetDocsDistributorAudioV1ListFilesIdsAsync(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs.
        /// </summary>
        /// <remarks>
        /// Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDailyIds)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsAudioDailyIds>> GetDocsDistributorAudioV1ListFilesIdsWithHttpInfoAsync(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time.
        /// </summary>
        /// <remarks>
        /// Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDaily</returns>
        System.Threading.Tasks.Task<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesUploadTimeAsync(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time.
        /// </summary>
        /// <remarks>
        /// Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </remarks>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDaily)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsAudioDaily>> GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfoAsync(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEventsAudioApi : IEventsAudioApiSync, IEventsAudioApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class EventsAudioApi : IEventsAudioApi
    {
        private FactSet.SDK.EventsandTranscripts.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        # region Response Type Disctionaries
        
        private static readonly Dictionary<HttpStatusCode, System.Type> GetDocsDistributorAudioV1HistoryFilesResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EventsAudioHistory) },
            { (HttpStatusCode)400, typeof(Error) },
            { (HttpStatusCode)401, typeof(Error) },
            { (HttpStatusCode)403, typeof(Error) },
            { (HttpStatusCode)500, typeof(Error) },
        };

        private static readonly Dictionary<HttpStatusCode, System.Type> GetDocsDistributorAudioV1ListFilesDateResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EventsAudioDaily) },
            { (HttpStatusCode)400, typeof(Error) },
            { (HttpStatusCode)401, typeof(Error) },
            { (HttpStatusCode)403, typeof(Error) },
            { (HttpStatusCode)500, typeof(Error) },
        };

        private static readonly Dictionary<HttpStatusCode, System.Type> GetDocsDistributorAudioV1ListFilesFileNameResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EventsAudioDailyFileName) },
            { (HttpStatusCode)400, typeof(Error) },
            { (HttpStatusCode)401, typeof(Error) },
            { (HttpStatusCode)403, typeof(Error) },
            { (HttpStatusCode)500, typeof(Error) },
        };

        private static readonly Dictionary<HttpStatusCode, System.Type> GetDocsDistributorAudioV1ListFilesIdsResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EventsAudioDailyIds) },
            { (HttpStatusCode)400, typeof(Error) },
            { (HttpStatusCode)401, typeof(Error) },
            { (HttpStatusCode)403, typeof(Error) },
            { (HttpStatusCode)500, typeof(Error) },
        };

        private static readonly Dictionary<HttpStatusCode, System.Type> GetDocsDistributorAudioV1ListFilesUploadTimeResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EventsAudioDaily) },
            { (HttpStatusCode)400, typeof(Error) },
            { (HttpStatusCode)401, typeof(Error) },
            { (HttpStatusCode)403, typeof(Error) },
            { (HttpStatusCode)500, typeof(Error) },
        };

        # endregion Response Type Disctionaries

        # region Api Response Objects
        

        # endregion Api Response Objects

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsAudioApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventsAudioApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsAudioApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventsAudioApi(string basePath)
        {
            this.Configuration = FactSet.SDK.EventsandTranscripts.Client.Configuration.MergeConfigurations(
                FactSet.SDK.EventsandTranscripts.Client.GlobalConfiguration.Instance,
                new FactSet.SDK.EventsandTranscripts.Client.Configuration { BasePath = basePath }
            );
            this.Client = new FactSet.SDK.EventsandTranscripts.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.EventsandTranscripts.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = FactSet.SDK.EventsandTranscripts.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsAudioApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EventsAudioApi(FactSet.SDK.EventsandTranscripts.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = FactSet.SDK.EventsandTranscripts.Client.Configuration.MergeConfigurations(
                FactSet.SDK.EventsandTranscripts.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new FactSet.SDK.EventsandTranscripts.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.EventsandTranscripts.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = FactSet.SDK.EventsandTranscripts.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventsAudioApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public EventsAudioApi(FactSet.SDK.EventsandTranscripts.Client.ISynchronousClient client, FactSet.SDK.EventsandTranscripts.Client.IAsynchronousClient asyncClient, FactSet.SDK.EventsandTranscripts.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = FactSet.SDK.EventsandTranscripts.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public FactSet.SDK.EventsandTranscripts.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public FactSet.SDK.EventsandTranscripts.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public FactSet.SDK.EventsandTranscripts.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public FactSet.SDK.EventsandTranscripts.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <returns>EventsAudioHistory</returns>
        public EventsAudioHistory GetDocsDistributorAudioV1HistoryFiles(int year, bool? trimmed = default(bool?))
        {
            var localVarResponse = GetDocsDistributorAudioV1HistoryFilesWithHttpInfo(year, trimmed);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <returns>ApiResponse of EventsAudioHistory</returns>
        public ApiResponse<EventsAudioHistory> GetDocsDistributorAudioV1HistoryFilesWithHttpInfo(int year, bool? trimmed = default(bool?))
        {
            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "year", year));
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1HistoryFilesResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EventsAudioHistory>("/audio/history", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1HistoryFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioHistory</returns>
        public async System.Threading.Tasks.Task<EventsAudioHistory>GetDocsDistributorAudioV1HistoryFilesAsync(int year, bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetDocsDistributorAudioV1HistoryFilesWithHttpInfoAsync(year, trimmed, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve historical audio recordings and related metadata within FactSet coverage.  This endpoint retrieves an object containing a pre-signed URL from which an archive of all audio data for a specified year can be downloaded.  * Returns **untrimmed** historical audio recordings, which include complete audio files such as intro music &amp; non-speaking portions, and related metadata dating back from May 10, 2011 to Sep 30, 2022.  * Returns **trimmed** historical audio recordings, which are audio files with the non-speaking portions removed, and related metadata dating back from May 10, 2011 to Dec 31, 2022. 
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="year">Specifies the year for which the historical audio recordings and related metadata are to be retrieved. </param>
        /// <param name="trimmed">Specifies if trimmed/untrimmed historical audio recordings should be returned. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioHistory)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EventsAudioHistory>> GetDocsDistributorAudioV1HistoryFilesWithHttpInfoAsync(int year, bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "year", year));
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1HistoryFilesResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EventsAudioHistory>("/audio/history", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1HistoryFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges. Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>EventsAudioDaily</returns>
        public EventsAudioDaily GetDocsDistributorAudioV1ListFilesDate(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?))
        {
            var localVarResponse = GetDocsDistributorAudioV1ListFilesDateWithHttpInfo(startDate, endDate, startDateRelative, endDateRelative, sourceCode, ids, trimmed, sort, paginationLimit, paginationOffset);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges. Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>ApiResponse of EventsAudioDaily</returns>
        public ApiResponse<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesDateWithHttpInfo(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?))
        {
            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (startDateRelative != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "startDateRelative", startDateRelative));
            }
            if (endDateRelative != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "endDateRelative", endDateRelative));
            }
            if (sourceCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "sourceCode", sourceCode));
            }
            if (ids != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "ids", ids));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "_sort", sort));
            }
            if (paginationLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationLimit", paginationLimit));
            }
            if (paginationOffset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationOffset", paginationOffset));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesDateResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EventsAudioDaily>("/audio/by-date", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesDate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges. Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDaily</returns>
        public async System.Threading.Tasks.Task<EventsAudioDaily>GetDocsDistributorAudioV1ListFilesDateAsync(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetDocsDistributorAudioV1ListFilesDateWithHttpInfoAsync(startDate, endDate, startDateRelative, endDateRelative, sourceCode, ids, trimmed, sort, paginationLimit, paginationOffset, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on a specific date ranges. Retrieves the most recent audio recordings based on specified dates and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The earliest date of the audio file the API should fetch for.  - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="endDate">The latest date of the audio file the API should fetch for. - Format: Should be absolute (YYYY-MM-DD).  (optional)</param>
        /// <param name="startDateRelative">The earliest date of the feed file the API should fetch based on the file timestamp.  - Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.   - *Either &#x60;startDate&#x60; or &#x60;startDateRelative&#x60; should be used, but not both.* - *If both &#x60;startDate&#x60; and &#x60;startDateRelative&#x60; are provided in the same request, the API will return an error.* - *If users provide future dates in requests for &#x60;startDate&#x60; or &#x60;startDateRelative&#x60;, the API will not return any data.*  (optional)</param>
        /// <param name="endDateRelative">The latest date of the feed file the API should fetch based on the file timestamp.   Format: Specify the date using a relative term as an integer: &#39;0&#39; for today, &#39;-1&#39; for yesterday, &#39;-2&#39; for two days ago, and so forth. Negative values are used to represent past dates.  - Either &#x60;endDate&#x60; or &#x60;endDateRelative&#x60; should be used, but not both. - If both &#x60;endDate&#x60; and &#x60;endDateRelative&#x60; are provided in the same request, the API will return an error. - If users provide future dates in requests for &#x60;endDate&#x60; or &#x60;endDateRelative&#x60;, the API will not return any data.  (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on startDate.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDaily)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EventsAudioDaily>> GetDocsDistributorAudioV1ListFilesDateWithHttpInfoAsync(DateTime? startDate = default(DateTime?), DateTime? endDate = default(DateTime?), int? startDateRelative = default(int?), int? endDateRelative = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (startDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "startDate", startDate));
            }
            if (endDate != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "endDate", endDate));
            }
            if (startDateRelative != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "startDateRelative", startDateRelative));
            }
            if (endDateRelative != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "endDateRelative", endDateRelative));
            }
            if (sourceCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "sourceCode", sourceCode));
            }
            if (ids != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "ids", ids));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "_sort", sort));
            }
            if (paginationLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationLimit", paginationLimit));
            }
            if (paginationOffset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationOffset", paginationOffset));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesDateResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EventsAudioDaily>("/audio/by-date", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesDate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name. Retrieves the latest audio recordings corresponding to the provided file name.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <returns>EventsAudioDailyFileName</returns>
        public EventsAudioDailyFileName GetDocsDistributorAudioV1ListFilesFileName(string fileName = default(string))
        {
            var localVarResponse = GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfo(fileName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name. Retrieves the latest audio recordings corresponding to the provided file name.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <returns>ApiResponse of EventsAudioDailyFileName</returns>
        public ApiResponse<EventsAudioDailyFileName> GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfo(string fileName = default(string))
        {
            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (fileName != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "fileName", fileName));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesFileNameResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EventsAudioDailyFileName>("/audio/by-file-name", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesFileName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name. Retrieves the latest audio recordings corresponding to the provided file name.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDailyFileName</returns>
        public async System.Threading.Tasks.Task<EventsAudioDailyFileName>GetDocsDistributorAudioV1ListFilesFileNameAsync(string fileName = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfoAsync(fileName, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on file name. Retrieves the latest audio recordings corresponding to the provided file name.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileName">This parameter is used to filter the data on based on the file name. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDailyFileName)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EventsAudioDailyFileName>> GetDocsDistributorAudioV1ListFilesFileNameWithHttpInfoAsync(string fileName = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (fileName != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "fileName", fileName));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesFileNameResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EventsAudioDailyFileName>("/audio/by-file-name", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesFileName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs. Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <returns>EventsAudioDailyIds</returns>
        public EventsAudioDailyIds GetDocsDistributorAudioV1ListFilesIds(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?))
        {
            var localVarResponse = GetDocsDistributorAudioV1ListFilesIdsWithHttpInfo(reportId, audioSourceId, trimmed);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs. Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <returns>ApiResponse of EventsAudioDailyIds</returns>
        public ApiResponse<EventsAudioDailyIds> GetDocsDistributorAudioV1ListFilesIdsWithHttpInfo(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?))
        {
            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (reportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "reportId", reportId));
            }
            if (audioSourceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "audioSourceId", audioSourceId));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesIdsResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EventsAudioDailyIds>("/audio/by-ids", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs. Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDailyIds</returns>
        public async System.Threading.Tasks.Task<EventsAudioDailyIds>GetDocsDistributorAudioV1ListFilesIdsAsync(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetDocsDistributorAudioV1ListFilesIdsWithHttpInfoAsync(reportId, audioSourceId, trimmed, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve the latest audio recordings along with their corresponding metadata from the FactSet coverage based on specific IDs. Retrieves the latest audio recordings based on the provided report ID and audio source ID.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="reportId">Unique identifier for fetching the audio file for an event. The same ID is used for the transcript of the same event.  (optional)</param>
        /// <param name="audioSourceId">Unique ID for an Internal recording specific to reportID. For example, ReportID X would have multiple recordings from different source (phone or webcast or vendor or replay). One ReportID can have multiple AudioSourceIDs.  (optional)</param>
        /// <param name="trimmed">This parameters helps to search trimmed audio files. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDailyIds)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EventsAudioDailyIds>> GetDocsDistributorAudioV1ListFilesIdsWithHttpInfoAsync(int? reportId = default(int?), int? audioSourceId = default(int?), bool? trimmed = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (reportId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "reportId", reportId));
            }
            if (audioSourceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "audioSourceId", audioSourceId));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesIdsResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EventsAudioDailyIds>("/audio/by-ids", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time. Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>EventsAudioDaily</returns>
        public EventsAudioDaily GetDocsDistributorAudioV1ListFilesUploadTime(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?))
        {
            var localVarResponse = GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfo(uploadTime, sourceCode, ids, trimmed, sort, paginationLimit, paginationOffset);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time. Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <returns>ApiResponse of EventsAudioDaily</returns>
        public ApiResponse<EventsAudioDaily> GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfo(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?))
        {
            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (uploadTime != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "uploadTime", uploadTime));
            }
            if (sourceCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "sourceCode", sourceCode));
            }
            if (ids != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "ids", ids));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "_sort", sort));
            }
            if (paginationLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationLimit", paginationLimit));
            }
            if (paginationOffset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationOffset", paginationOffset));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesUploadTimeResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EventsAudioDaily>("/audio/by-upload-time", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesUploadTime", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time. Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventsAudioDaily</returns>
        public async System.Threading.Tasks.Task<EventsAudioDaily>GetDocsDistributorAudioV1ListFilesUploadTimeAsync(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfoAsync(uploadTime, sourceCode, ids, trimmed, sort, paginationLimit, paginationOffset, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve latest audio recordings and related metadata within FactSet coverage based on upload time. Returns the latest audio recordings based on upload time and allows filtering through both source code and Ids.
        /// </summary>
        /// <exception cref="FactSet.SDK.EventsandTranscripts.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadTime">This parameter filters data based on uploadTime relative to the current time, in hours. For example:- uploadTime &#x3D; -15 (fetches audio files between 15 hours ago and now)  Minimum is 1 hour i.e., uploadTime&#x3D; -1  Maximum is 1 week/168 hours i.e., uploadTime&#x3D;-168 (optional)</param>
        /// <param name="sourceCode">This parameter filters the results based on Source of the Audio file. Below are the descriptions for each Source Code - * Phone &#x3D; Originated from phone call * Webcast &#x3D; Originated from a webcast * Vendor &#x3D; Received from vendor * WebcastReplay &#x3D; Replay of a webcast * Flash &#x3D; Identical to webcast; can merge with \&quot;Webcast\&quot; in the future * Replay &#x3D; Phone replay (optional)</param>
        /// <param name="ids">This parameter filters the results based on ticker-region or Entity ID or the combination of both. A comma is used to separate each identifier.  (optional)</param>
        /// <param name="trimmed">This parameter helps to search for trimmed audio files, with the non-speaking portions removed, and related metadata. The data ranges from May 10, 2011 to Dec 31, 2022.  (optional, default to false)</param>
        /// <param name="sort">Enables sorting data in ascending or descending chronological order based on uploadTime.  (optional)</param>
        /// <param name="paginationLimit">Specifies the number of results to return per page. (optional, default to 25)</param>
        /// <param name="paginationOffset">Page number of the results to return. (optional, default to 0)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventsAudioDaily)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EventsAudioDaily>> GetDocsDistributorAudioV1ListFilesUploadTimeWithHttpInfoAsync(int? uploadTime = default(int?), string sourceCode = default(string), List<string> ids = default(List<string>), bool? trimmed = default(bool?), List<string> sort = default(List<string>), int? paginationLimit = default(int?), int? paginationOffset = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.EventsandTranscripts.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.EventsandTranscripts.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.EventsandTranscripts.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (uploadTime != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "uploadTime", uploadTime));
            }
            if (sourceCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "sourceCode", sourceCode));
            }
            if (ids != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "ids", ids));
            }
            if (trimmed != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "trimmed", trimmed));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("csv", "_sort", sort));
            }
            if (paginationLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationLimit", paginationLimit));
            }
            if (paginationOffset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.EventsandTranscripts.Client.ClientUtils.ParameterToMultiMap("", "_paginationOffset", paginationOffset));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.EventsandTranscripts.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetDocsDistributorAudioV1ListFilesUploadTimeResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EventsAudioDaily>("/audio/by-upload-time", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDocsDistributorAudioV1ListFilesUploadTime", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
