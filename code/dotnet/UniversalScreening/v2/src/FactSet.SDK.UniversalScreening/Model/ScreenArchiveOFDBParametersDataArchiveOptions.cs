/*
 * Universal Screening API
 *
 * Through the Universal Screening API, you can access the power of FactSet's Universal Screening Application. Calculate and return the results of your saved Universal Screens.
 *
 * The version of the OpenAPI document: 2.0.2
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.UniversalScreening.Client.OpenAPIDateConverter;

namespace FactSet.SDK.UniversalScreening.Model
{
    /// <summary>
    /// Archive-specific parameters
    /// </summary>
    [DataContract(Name = "ScreenArchiveOFDBParameters_data_archiveOptions")]
    public partial class ScreenArchiveOFDBParametersDataArchiveOptions : IEquatable<ScreenArchiveOFDBParametersDataArchiveOptions>, IValidatableObject
    {
        /// <summary>
        /// Type of archive.\\ &#x60;ofdbSymbols&#x60;: Archives the list of identifiers that passed the screen to an OFDB file.\\ &#x60;ofdb&#x60;: Archives the results of the screen to a time series OFDB. A mapping between Universal Screening and the OFDB must be created and saved in the screen.\\ &#x60;ofdbNts&#x60;: Archives the results of the screen to a non-time series OFDB. A mapping between Universal Screening and the OFDB database must be created and saved in the screen.\\ &#x60;ofdbQuickNts&#x60;: Archives the results of the screen to a non-time series OFDB without requiring a Universal Screening-to-OFDB map. By default, all columns in the screen will be archived to the OFDB. Each column&#39;s parameter reference name will be used as the OFDB field name. Use the &#x60;quickColumns&#x60; property to specify which parameters to archive.
        /// </summary>
        /// <value>Type of archive.\\ &#x60;ofdbSymbols&#x60;: Archives the list of identifiers that passed the screen to an OFDB file.\\ &#x60;ofdb&#x60;: Archives the results of the screen to a time series OFDB. A mapping between Universal Screening and the OFDB must be created and saved in the screen.\\ &#x60;ofdbNts&#x60;: Archives the results of the screen to a non-time series OFDB. A mapping between Universal Screening and the OFDB database must be created and saved in the screen.\\ &#x60;ofdbQuickNts&#x60;: Archives the results of the screen to a non-time series OFDB without requiring a Universal Screening-to-OFDB map. By default, all columns in the screen will be archived to the OFDB. Each column&#39;s parameter reference name will be used as the OFDB field name. Use the &#x60;quickColumns&#x60; property to specify which parameters to archive.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ArchiveTypeEnum
        {
            /// <summary>
            /// Enum OfdbSymbols for value: ofdbSymbols
            /// </summary>
            [EnumMember(Value = "ofdbSymbols")]
            OfdbSymbols = 1,

            /// <summary>
            /// Enum Ofdb for value: ofdb
            /// </summary>
            [EnumMember(Value = "ofdb")]
            Ofdb = 2,

            /// <summary>
            /// Enum OfdbNts for value: ofdbNts
            /// </summary>
            [EnumMember(Value = "ofdbNts")]
            OfdbNts = 3,

            /// <summary>
            /// Enum OfdbQuickNts for value: ofdbQuickNts
            /// </summary>
            [EnumMember(Value = "ofdbQuickNts")]
            OfdbQuickNts = 4

        }


        /// <summary>
        /// Type of archive.\\ &#x60;ofdbSymbols&#x60;: Archives the list of identifiers that passed the screen to an OFDB file.\\ &#x60;ofdb&#x60;: Archives the results of the screen to a time series OFDB. A mapping between Universal Screening and the OFDB must be created and saved in the screen.\\ &#x60;ofdbNts&#x60;: Archives the results of the screen to a non-time series OFDB. A mapping between Universal Screening and the OFDB database must be created and saved in the screen.\\ &#x60;ofdbQuickNts&#x60;: Archives the results of the screen to a non-time series OFDB without requiring a Universal Screening-to-OFDB map. By default, all columns in the screen will be archived to the OFDB. Each column&#39;s parameter reference name will be used as the OFDB field name. Use the &#x60;quickColumns&#x60; property to specify which parameters to archive.
        /// </summary>
        /// <value>Type of archive.\\ &#x60;ofdbSymbols&#x60;: Archives the list of identifiers that passed the screen to an OFDB file.\\ &#x60;ofdb&#x60;: Archives the results of the screen to a time series OFDB. A mapping between Universal Screening and the OFDB must be created and saved in the screen.\\ &#x60;ofdbNts&#x60;: Archives the results of the screen to a non-time series OFDB. A mapping between Universal Screening and the OFDB database must be created and saved in the screen.\\ &#x60;ofdbQuickNts&#x60;: Archives the results of the screen to a non-time series OFDB without requiring a Universal Screening-to-OFDB map. By default, all columns in the screen will be archived to the OFDB. Each column&#39;s parameter reference name will be used as the OFDB field name. Use the &#x60;quickColumns&#x60; property to specify which parameters to archive.</value>
        [DataMember(Name = "archiveType", IsRequired = true, EmitDefaultValue = false)]
        public ArchiveTypeEnum ArchiveType { get; set; }
        /// <summary>
        /// The type of symbol to be saved to the SYMBOL field of the OFDB\\ &#x60;cusip&#x60;: Recommended. Primarily CUSIP for North American listed securities and SEDOL for the rest of the world.\\ &#x60;ticker&#x60;: Should only be used when writing to an existing OFDB that uses Tickers in the symbol column. Primarily Tickers for North American listed securities, QUICK Codes for Japanese listed securities, and SEDOL for the rest of the world. Applicable for equity screen archives.\\ &#x60;isin&#x60;: International Securities Identification Number (ISIN). Applicable for debt screen archives.
        /// </summary>
        /// <value>The type of symbol to be saved to the SYMBOL field of the OFDB\\ &#x60;cusip&#x60;: Recommended. Primarily CUSIP for North American listed securities and SEDOL for the rest of the world.\\ &#x60;ticker&#x60;: Should only be used when writing to an existing OFDB that uses Tickers in the symbol column. Primarily Tickers for North American listed securities, QUICK Codes for Japanese listed securities, and SEDOL for the rest of the world. Applicable for equity screen archives.\\ &#x60;isin&#x60;: International Securities Identification Number (ISIN). Applicable for debt screen archives.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum SymbolTypeEnum
        {
            /// <summary>
            /// Enum Cusip for value: cusip
            /// </summary>
            [EnumMember(Value = "cusip")]
            Cusip = 1,

            /// <summary>
            /// Enum Ticker for value: ticker
            /// </summary>
            [EnumMember(Value = "ticker")]
            Ticker = 2,

            /// <summary>
            /// Enum Isin for value: isin
            /// </summary>
            [EnumMember(Value = "isin")]
            Isin = 3

        }


        /// <summary>
        /// The type of symbol to be saved to the SYMBOL field of the OFDB\\ &#x60;cusip&#x60;: Recommended. Primarily CUSIP for North American listed securities and SEDOL for the rest of the world.\\ &#x60;ticker&#x60;: Should only be used when writing to an existing OFDB that uses Tickers in the symbol column. Primarily Tickers for North American listed securities, QUICK Codes for Japanese listed securities, and SEDOL for the rest of the world. Applicable for equity screen archives.\\ &#x60;isin&#x60;: International Securities Identification Number (ISIN). Applicable for debt screen archives.
        /// </summary>
        /// <value>The type of symbol to be saved to the SYMBOL field of the OFDB\\ &#x60;cusip&#x60;: Recommended. Primarily CUSIP for North American listed securities and SEDOL for the rest of the world.\\ &#x60;ticker&#x60;: Should only be used when writing to an existing OFDB that uses Tickers in the symbol column. Primarily Tickers for North American listed securities, QUICK Codes for Japanese listed securities, and SEDOL for the rest of the world. Applicable for equity screen archives.\\ &#x60;isin&#x60;: International Securities Identification Number (ISIN). Applicable for debt screen archives.</value>
        [DataMember(Name = "symbolType", EmitDefaultValue = true)]
        public SymbolTypeEnum? SymbolType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ScreenArchiveOFDBParametersDataArchiveOptions" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ScreenArchiveOFDBParametersDataArchiveOptions() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ScreenArchiveOFDBParametersDataArchiveOptions" /> class.
        /// </summary>
        /// <param name="archiveDate">YYYYMMDD date to archive to.</param>
        /// <param name="archiveType">Type of archive.\\ &#x60;ofdbSymbols&#x60;: Archives the list of identifiers that passed the screen to an OFDB file.\\ &#x60;ofdb&#x60;: Archives the results of the screen to a time series OFDB. A mapping between Universal Screening and the OFDB must be created and saved in the screen.\\ &#x60;ofdbNts&#x60;: Archives the results of the screen to a non-time series OFDB. A mapping between Universal Screening and the OFDB database must be created and saved in the screen.\\ &#x60;ofdbQuickNts&#x60;: Archives the results of the screen to a non-time series OFDB without requiring a Universal Screening-to-OFDB map. By default, all columns in the screen will be archived to the OFDB. Each column&#39;s parameter reference name will be used as the OFDB field name. Use the &#x60;quickColumns&#x60; property to specify which parameters to archive. (required).</param>
        /// <param name="autoSymbolUpdates">Flag to enable automatic symbol updates.</param>
        /// <param name="existed">Indicates that the output file exists.</param>
        /// <param name="filename">OFDB Filename to archive to (required).</param>
        /// <param name="overwriteData">If true and target file (or date for a time series file) exists, it will be cleared before archiving.</param>
        /// <param name="quickColumns">Space delimited list of parameter references to be archived, which are UPPERCASED with the #P. omitted.</param>
        /// <param name="symbolType">The type of symbol to be saved to the SYMBOL field of the OFDB\\ &#x60;cusip&#x60;: Recommended. Primarily CUSIP for North American listed securities and SEDOL for the rest of the world.\\ &#x60;ticker&#x60;: Should only be used when writing to an existing OFDB that uses Tickers in the symbol column. Primarily Tickers for North American listed securities, QUICK Codes for Japanese listed securities, and SEDOL for the rest of the world. Applicable for equity screen archives.\\ &#x60;isin&#x60;: International Securities Identification Number (ISIN). Applicable for debt screen archives..</param>
        /// <param name="timeSeries">Has no effect. Use the &#x60;archiveType&#x60; property..</param>
        /// <param name="unsplitHistory">Flag indicating split adjust.</param>
        /// <param name="useReportOrder">If true, archive in report order.</param>
        public ScreenArchiveOFDBParametersDataArchiveOptions(ArchiveTypeEnum archiveType, string filename,string archiveDate = default(string), bool autoSymbolUpdates = default(bool), bool existed = default(bool), bool overwriteData = default(bool), string quickColumns = default(string), SymbolTypeEnum? symbolType = default(SymbolTypeEnum?), bool timeSeries = default(bool), bool unsplitHistory = default(bool), bool useReportOrder = default(bool))
        {
            this.ArchiveType = archiveType;
            // to ensure "filename" is required (not null)
            if (filename == null) {
                throw new ArgumentNullException("filename is a required property for ScreenArchiveOFDBParametersDataArchiveOptions and cannot be null");
            }
            this.Filename = filename;
            this.ArchiveDate = archiveDate;
            this.AutoSymbolUpdates = autoSymbolUpdates;
            this.Existed = existed;
            this.OverwriteData = overwriteData;
            this.QuickColumns = quickColumns;
            this.SymbolType = symbolType;
            this.TimeSeries = timeSeries;
            this.UnsplitHistory = unsplitHistory;
            this.UseReportOrder = useReportOrder;
        }

        /// <summary>
        /// YYYYMMDD date to archive to
        /// </summary>
        /// <value>YYYYMMDD date to archive to</value>
        [DataMember(Name = "archiveDate", EmitDefaultValue = true)]
        public string ArchiveDate { get; set; }

        /// <summary>
        /// Flag to enable automatic symbol updates
        /// </summary>
        /// <value>Flag to enable automatic symbol updates</value>
        [DataMember(Name = "autoSymbolUpdates", EmitDefaultValue = true)]
        public bool AutoSymbolUpdates { get; set; }

        /// <summary>
        /// Indicates that the output file exists
        /// </summary>
        /// <value>Indicates that the output file exists</value>
        [DataMember(Name = "existed", EmitDefaultValue = true)]
        public bool Existed { get; set; }

        /// <summary>
        /// OFDB Filename to archive to
        /// </summary>
        /// <value>OFDB Filename to archive to</value>
        [DataMember(Name = "filename", IsRequired = true, EmitDefaultValue = false)]
        public string Filename { get; set; }

        /// <summary>
        /// If true and target file (or date for a time series file) exists, it will be cleared before archiving
        /// </summary>
        /// <value>If true and target file (or date for a time series file) exists, it will be cleared before archiving</value>
        [DataMember(Name = "overwriteData", EmitDefaultValue = true)]
        public bool OverwriteData { get; set; }

        /// <summary>
        /// Space delimited list of parameter references to be archived, which are UPPERCASED with the #P. omitted
        /// </summary>
        /// <value>Space delimited list of parameter references to be archived, which are UPPERCASED with the #P. omitted</value>
        [DataMember(Name = "quickColumns", EmitDefaultValue = true)]
        public string QuickColumns { get; set; }

        /// <summary>
        /// Has no effect. Use the &#x60;archiveType&#x60; property.
        /// </summary>
        /// <value>Has no effect. Use the &#x60;archiveType&#x60; property.</value>
        [DataMember(Name = "timeSeries", EmitDefaultValue = true)]
        [Obsolete]
        public bool TimeSeries { get; set; }

        /// <summary>
        /// Flag indicating split adjust
        /// </summary>
        /// <value>Flag indicating split adjust</value>
        [DataMember(Name = "unsplitHistory", EmitDefaultValue = true)]
        public bool UnsplitHistory { get; set; }

        /// <summary>
        /// If true, archive in report order
        /// </summary>
        /// <value>If true, archive in report order</value>
        [DataMember(Name = "useReportOrder", EmitDefaultValue = true)]
        public bool UseReportOrder { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ScreenArchiveOFDBParametersDataArchiveOptions {\n");
            sb.Append("  ArchiveDate: ").Append(ArchiveDate).Append("\n");
            sb.Append("  ArchiveType: ").Append(ArchiveType).Append("\n");
            sb.Append("  AutoSymbolUpdates: ").Append(AutoSymbolUpdates).Append("\n");
            sb.Append("  Existed: ").Append(Existed).Append("\n");
            sb.Append("  Filename: ").Append(Filename).Append("\n");
            sb.Append("  OverwriteData: ").Append(OverwriteData).Append("\n");
            sb.Append("  QuickColumns: ").Append(QuickColumns).Append("\n");
            sb.Append("  SymbolType: ").Append(SymbolType).Append("\n");
            sb.Append("  TimeSeries: ").Append(TimeSeries).Append("\n");
            sb.Append("  UnsplitHistory: ").Append(UnsplitHistory).Append("\n");
            sb.Append("  UseReportOrder: ").Append(UseReportOrder).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ScreenArchiveOFDBParametersDataArchiveOptions);
        }

        /// <summary>
        /// Returns true if ScreenArchiveOFDBParametersDataArchiveOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of ScreenArchiveOFDBParametersDataArchiveOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ScreenArchiveOFDBParametersDataArchiveOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ArchiveDate == input.ArchiveDate ||
                    (this.ArchiveDate != null &&
                    this.ArchiveDate.Equals(input.ArchiveDate))
                ) && 
                (
                    this.ArchiveType == input.ArchiveType ||
                    this.ArchiveType.Equals(input.ArchiveType)
                ) && 
                (
                    this.AutoSymbolUpdates == input.AutoSymbolUpdates ||
                    this.AutoSymbolUpdates.Equals(input.AutoSymbolUpdates)
                ) && 
                (
                    this.Existed == input.Existed ||
                    this.Existed.Equals(input.Existed)
                ) && 
                (
                    this.Filename == input.Filename ||
                    (this.Filename != null &&
                    this.Filename.Equals(input.Filename))
                ) && 
                (
                    this.OverwriteData == input.OverwriteData ||
                    this.OverwriteData.Equals(input.OverwriteData)
                ) && 
                (
                    this.QuickColumns == input.QuickColumns ||
                    (this.QuickColumns != null &&
                    this.QuickColumns.Equals(input.QuickColumns))
                ) && 
                (
                    this.SymbolType == input.SymbolType ||
                    this.SymbolType.Equals(input.SymbolType)
                ) && 
                (
                    this.TimeSeries == input.TimeSeries ||
                    this.TimeSeries.Equals(input.TimeSeries)
                ) && 
                (
                    this.UnsplitHistory == input.UnsplitHistory ||
                    this.UnsplitHistory.Equals(input.UnsplitHistory)
                ) && 
                (
                    this.UseReportOrder == input.UseReportOrder ||
                    this.UseReportOrder.Equals(input.UseReportOrder)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ArchiveDate != null)
                {
                    hashCode = (hashCode * 59) + this.ArchiveDate.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ArchiveType.GetHashCode();
                hashCode = (hashCode * 59) + this.AutoSymbolUpdates.GetHashCode();
                hashCode = (hashCode * 59) + this.Existed.GetHashCode();
                if (this.Filename != null)
                {
                    hashCode = (hashCode * 59) + this.Filename.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.OverwriteData.GetHashCode();
                if (this.QuickColumns != null)
                {
                    hashCode = (hashCode * 59) + this.QuickColumns.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.SymbolType.GetHashCode();
                hashCode = (hashCode * 59) + this.TimeSeries.GetHashCode();
                hashCode = (hashCode * 59) + this.UnsplitHistory.GetHashCode();
                hashCode = (hashCode * 59) + this.UseReportOrder.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // ArchiveDate (string) maxLength
            if (this.ArchiveDate != null && this.ArchiveDate.Length > 8)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ArchiveDate, length must be less than 8.", new [] { "ArchiveDate" });
            }

            // ArchiveDate (string) minLength
            if (this.ArchiveDate != null && this.ArchiveDate.Length < 8)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ArchiveDate, length must be greater than 8.", new [] { "ArchiveDate" });
            }

            // ArchiveDate (string) pattern
            Regex regexArchiveDate = new Regex(@"^\\d{8}$", RegexOptions.CultureInvariant);
            if (false == regexArchiveDate.Match(this.ArchiveDate).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ArchiveDate, must match a pattern of " + regexArchiveDate, new [] { "ArchiveDate" });
            }

            yield break;
        }
    }

}
