/*
 * Universal Screening API
 *
 * Through the Universal Screening API, you can access the power of FactSet's Universal Screening Application. Calculate and return the results of your saved Universal Screens.
 *
 * The version of the OpenAPI document: 2.0.2
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.UniversalScreening.Client.OpenAPIDateConverter;

namespace FactSet.SDK.UniversalScreening.Model
{
    /// <summary>
    /// Generic options that can be applied to endpoint output.
    /// </summary>
    [DataContract(Name = "CalculateMetadata")]
    public partial class CalculateMetadata : IEquatable<CalculateMetadata>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CalculateMetadata" /> class.
        /// </summary>
        /// <param name="sort">An array of parameter references to sort by to override the sort set in the screen document. Format is \&quot;#P.&lt;parameter_name&gt;\&quot; for ascending sort, \&quot;-#P.&lt;parameter_name&gt;\&quot; for descending. Will sort by references in order of appearance in the provided list, i.e. will sort first by the 0th reference, then the 1st reference and so on. Limit of 7 references..</param>
        public CalculateMetadata(List<string> sort = default(List<string>))
        {
            this.Sort = sort;
        }

        /// <summary>
        /// An array of parameter references to sort by to override the sort set in the screen document. Format is \&quot;#P.&lt;parameter_name&gt;\&quot; for ascending sort, \&quot;-#P.&lt;parameter_name&gt;\&quot; for descending. Will sort by references in order of appearance in the provided list, i.e. will sort first by the 0th reference, then the 1st reference and so on. Limit of 7 references.
        /// </summary>
        /// <value>An array of parameter references to sort by to override the sort set in the screen document. Format is \&quot;#P.&lt;parameter_name&gt;\&quot; for ascending sort, \&quot;-#P.&lt;parameter_name&gt;\&quot; for descending. Will sort by references in order of appearance in the provided list, i.e. will sort first by the 0th reference, then the 1st reference and so on. Limit of 7 references.</value>
        [DataMember(Name = "sort", EmitDefaultValue = false)]
        public List<string> Sort { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CalculateMetadata {\n");
            sb.Append("  Sort: ").Append(Sort).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CalculateMetadata);
        }

        /// <summary>
        /// Returns true if CalculateMetadata instances are equal
        /// </summary>
        /// <param name="input">Instance of CalculateMetadata to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CalculateMetadata input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Sort == input.Sort ||
                    this.Sort != null &&
                    input.Sort != null &&
                    this.Sort.SequenceEqual(input.Sort)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Sort != null)
                {
                    hashCode = (hashCode * 59) + this.Sort.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
