/*
 * Universal Screening API
 *
 * Through the Universal Screening API, you can access the power of FactSet's Universal Screening Application. Calculate and return the results of your saved Universal Screens.
 *
 * The version of the OpenAPI document: 2.0.2
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.UniversalScreening.Client.OpenAPIDateConverter;

namespace FactSet.SDK.UniversalScreening.Model
{
    /// <summary>
    /// Options applied to PDF output.
    /// </summary>
    [DataContract(Name = "PdfOptions")]
    public partial class PdfOptions : IEquatable<PdfOptions>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PdfOptions" /> class.
        /// </summary>
        /// <param name="applyAlternateRowShading">Specifies whether every other row shading should be applied to the output. By default, this option is set to false, which means that every other row shading will not be included in the download. (default to false).</param>
        /// <param name="applyFilters">Specifies whether the filters present in the screen should be applied to the output. By default, this option is set to false, which means that filters will not be applied and all securities passing the screen will be included in the output. (default to false).</param>
        /// <param name="applyTextWrapping">Specifies that the text in cells be wrapped if there are more characters than can fit in the space available. By default, this option is set to true. (default to true).</param>
        /// <param name="orientationLandscape">Specifies the page orientation of the downloaded file. Value true for Landscape, false for Portrait. By default this is set to false. (default to false).</param>
        /// <param name="customTitle">Sets a custom title for the download..</param>
        /// <param name="customSubtitle">Sets a custom subtitle for the download..</param>
        public PdfOptions(bool? applyAlternateRowShading = false, bool? applyFilters = false, bool? applyTextWrapping = true, bool? orientationLandscape = false, string customTitle = default(string), string customSubtitle = default(string))
        {
            // use default value if no "applyAlternateRowShading" provided
            this.ApplyAlternateRowShading = applyAlternateRowShading ?? false;
            // use default value if no "applyFilters" provided
            this.ApplyFilters = applyFilters ?? false;
            // use default value if no "applyTextWrapping" provided
            this.ApplyTextWrapping = applyTextWrapping ?? true;
            // use default value if no "orientationLandscape" provided
            this.OrientationLandscape = orientationLandscape ?? false;
            this.CustomTitle = customTitle;
            this.CustomSubtitle = customSubtitle;
        }

        /// <summary>
        /// Specifies whether every other row shading should be applied to the output. By default, this option is set to false, which means that every other row shading will not be included in the download.
        /// </summary>
        /// <value>Specifies whether every other row shading should be applied to the output. By default, this option is set to false, which means that every other row shading will not be included in the download.</value>
        [DataMember(Name = "applyAlternateRowShading", EmitDefaultValue = true)]
        public bool? ApplyAlternateRowShading { get; set; }

        /// <summary>
        /// Specifies whether the filters present in the screen should be applied to the output. By default, this option is set to false, which means that filters will not be applied and all securities passing the screen will be included in the output.
        /// </summary>
        /// <value>Specifies whether the filters present in the screen should be applied to the output. By default, this option is set to false, which means that filters will not be applied and all securities passing the screen will be included in the output.</value>
        [DataMember(Name = "applyFilters", EmitDefaultValue = true)]
        public bool? ApplyFilters { get; set; }

        /// <summary>
        /// Specifies that the text in cells be wrapped if there are more characters than can fit in the space available. By default, this option is set to true.
        /// </summary>
        /// <value>Specifies that the text in cells be wrapped if there are more characters than can fit in the space available. By default, this option is set to true.</value>
        [DataMember(Name = "applyTextWrapping", EmitDefaultValue = true)]
        public bool? ApplyTextWrapping { get; set; }

        /// <summary>
        /// Specifies the page orientation of the downloaded file. Value true for Landscape, false for Portrait. By default this is set to false.
        /// </summary>
        /// <value>Specifies the page orientation of the downloaded file. Value true for Landscape, false for Portrait. By default this is set to false.</value>
        [DataMember(Name = "orientationLandscape", EmitDefaultValue = true)]
        public bool? OrientationLandscape { get; set; }

        /// <summary>
        /// Sets a custom title for the download.
        /// </summary>
        /// <value>Sets a custom title for the download.</value>
        [DataMember(Name = "customTitle", EmitDefaultValue = true)]
        public string CustomTitle { get; set; }

        /// <summary>
        /// Sets a custom subtitle for the download.
        /// </summary>
        /// <value>Sets a custom subtitle for the download.</value>
        [DataMember(Name = "customSubtitle", EmitDefaultValue = true)]
        public string CustomSubtitle { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PdfOptions {\n");
            sb.Append("  ApplyAlternateRowShading: ").Append(ApplyAlternateRowShading).Append("\n");
            sb.Append("  ApplyFilters: ").Append(ApplyFilters).Append("\n");
            sb.Append("  ApplyTextWrapping: ").Append(ApplyTextWrapping).Append("\n");
            sb.Append("  OrientationLandscape: ").Append(OrientationLandscape).Append("\n");
            sb.Append("  CustomTitle: ").Append(CustomTitle).Append("\n");
            sb.Append("  CustomSubtitle: ").Append(CustomSubtitle).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PdfOptions);
        }

        /// <summary>
        /// Returns true if PdfOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of PdfOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PdfOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ApplyAlternateRowShading == input.ApplyAlternateRowShading ||
                    (this.ApplyAlternateRowShading != null &&
                    this.ApplyAlternateRowShading.Equals(input.ApplyAlternateRowShading))
                ) && 
                (
                    this.ApplyFilters == input.ApplyFilters ||
                    (this.ApplyFilters != null &&
                    this.ApplyFilters.Equals(input.ApplyFilters))
                ) && 
                (
                    this.ApplyTextWrapping == input.ApplyTextWrapping ||
                    (this.ApplyTextWrapping != null &&
                    this.ApplyTextWrapping.Equals(input.ApplyTextWrapping))
                ) && 
                (
                    this.OrientationLandscape == input.OrientationLandscape ||
                    (this.OrientationLandscape != null &&
                    this.OrientationLandscape.Equals(input.OrientationLandscape))
                ) && 
                (
                    this.CustomTitle == input.CustomTitle ||
                    (this.CustomTitle != null &&
                    this.CustomTitle.Equals(input.CustomTitle))
                ) && 
                (
                    this.CustomSubtitle == input.CustomSubtitle ||
                    (this.CustomSubtitle != null &&
                    this.CustomSubtitle.Equals(input.CustomSubtitle))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ApplyAlternateRowShading != null)
                {
                    hashCode = (hashCode * 59) + this.ApplyAlternateRowShading.GetHashCode();
                }
                if (this.ApplyFilters != null)
                {
                    hashCode = (hashCode * 59) + this.ApplyFilters.GetHashCode();
                }
                if (this.ApplyTextWrapping != null)
                {
                    hashCode = (hashCode * 59) + this.ApplyTextWrapping.GetHashCode();
                }
                if (this.OrientationLandscape != null)
                {
                    hashCode = (hashCode * 59) + this.OrientationLandscape.GetHashCode();
                }
                if (this.CustomTitle != null)
                {
                    hashCode = (hashCode * 59) + this.CustomTitle.GetHashCode();
                }
                if (this.CustomSubtitle != null)
                {
                    hashCode = (hashCode * 59) + this.CustomSubtitle.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
