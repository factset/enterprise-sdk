/*
 * FactSet Concordance API
 *
 * The FactSet Concordance API provides the ability to programmatically look up several types of entities by their name and other attributes. It attempts to match attributes that you supply for the entity and returns as many match candidates as it can find. The result is a \"concorded\" FactSet Entity Permanent identifier.  The Entity Identifier can then be used as input throughout FactSet's Content soultions, such as Content APIs and Standard DataFeeds.<p> There are two types of workflows supported in the API. The first workflow type follows traditional API conventions in that a request is accepted and a response is returned synchronously. The second workflow type involves a background task. With this workflow, a task is created for uploading a set of queries, and then the client polls for the task to complete. Once the task has completed, the client retrieves the concordance results throught the decisions endpoint.</p> 
 *
 * The version of the OpenAPI document: 2.3.1
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using FactSet.SDK.FactSetConcordance.Client;
using FactSet.SDK.FactSetConcordance.Model;
using FactSet.SDK.Utils.Authentication;

namespace FactSet.SDK.FactSetConcordance.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMappingsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Deletes mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <returns>EntityMappingDeleteResponse</returns>
        EntityMappingDeleteResponse GetEntityMappingDeleteForList(EntityMappingDeleteRequest entityMappingDeleteRequest);

        /// <summary>
        /// Deletes mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <returns>ApiResponse of EntityMappingDeleteResponse</returns>
        ApiResponse<EntityMappingDeleteResponse> GetEntityMappingDeleteForListWithHttpInfo(EntityMappingDeleteRequest entityMappingDeleteRequest);
        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>EntityResponse</returns>
        EntityResponse GetEntityMappingForList(EntityMappingRequest entityMappingRequest);

        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>ApiResponse of EntityResponse</returns>
        ApiResponse<EntityResponse> GetEntityMappingForListWithHttpInfo(EntityMappingRequest entityMappingRequest);
        /// <summary>
        /// Retrieve all saved mappings within a requested universe
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings within a requested universe. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>EntityUniverseResponse</returns>
        EntityUniverseResponse GetEntityUniverse(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?));

        /// <summary>
        /// Retrieve all saved mappings within a requested universe
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings within a requested universe. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        ApiResponse<EntityUniverseResponse> GetEntityUniverseWithHttpInfo(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?));
        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <returns>EntityUniverseResponse</returns>
        EntityUniverseResponse GetEntityUniverseForList(EntityUniverseRequest entityUniverseRequest);

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        ApiResponse<EntityUniverseResponse> GetEntityUniverseForListWithHttpInfo(EntityUniverseRequest entityUniverseRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMappingsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Deletes mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityMappingDeleteResponse</returns>
        System.Threading.Tasks.Task<EntityMappingDeleteResponse> GetEntityMappingDeleteForListAsync(EntityMappingDeleteRequest entityMappingDeleteRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Deletes mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityMappingDeleteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityMappingDeleteResponse>> GetEntityMappingDeleteForListWithHttpInfoAsync(EntityMappingDeleteRequest entityMappingDeleteRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityResponse</returns>
        System.Threading.Tasks.Task<EntityResponse> GetEntityMappingForListAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityResponse>> GetEntityMappingForListWithHttpInfoAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve all saved mappings within a requested universe
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings within a requested universe. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        System.Threading.Tasks.Task<EntityUniverseResponse> GetEntityUniverseAsync(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve all saved mappings within a requested universe
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings within a requested universe. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseWithHttpInfoAsync(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        System.Threading.Tasks.Task<EntityUniverseResponse> GetEntityUniverseForListAsync(EntityUniverseRequest entityUniverseRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseForListWithHttpInfoAsync(EntityUniverseRequest entityUniverseRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMappingsApi : IMappingsApiSync, IMappingsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MappingsApi : IMappingsApi
    {
        private FactSet.SDK.FactSetConcordance.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        # region Response Type Disctionaries
                private static readonly Dictionary<HttpStatusCode, System.Type> GetEntityMappingDeleteForListResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityMappingDeleteResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };
        private static readonly Dictionary<HttpStatusCode, System.Type> GetEntityMappingForListResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };
        private static readonly Dictionary<HttpStatusCode, System.Type> GetEntityUniverseResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityUniverseResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };
        private static readonly Dictionary<HttpStatusCode, System.Type> GetEntityUniverseForListResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityUniverseResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };

        # endregion Response Type Disctionaries

        # region Api Response Objects
         

        # endregion Api Response Objects

        /// <summary>
        /// Initializes a new instance of the <see cref="MappingsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MappingsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MappingsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MappingsApi(string basePath)
        {
            this.Configuration = FactSet.SDK.FactSetConcordance.Client.Configuration.MergeConfigurations(
                FactSet.SDK.FactSetConcordance.Client.GlobalConfiguration.Instance,
                new FactSet.SDK.FactSetConcordance.Client.Configuration { BasePath = basePath }
            );
            this.Client = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MappingsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MappingsApi(FactSet.SDK.FactSetConcordance.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = FactSet.SDK.FactSetConcordance.Client.Configuration.MergeConfigurations(
                FactSet.SDK.FactSetConcordance.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MappingsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public MappingsApi(FactSet.SDK.FactSetConcordance.Client.ISynchronousClient client, FactSet.SDK.FactSetConcordance.Client.IAsynchronousClient asyncClient, FactSet.SDK.FactSetConcordance.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public FactSet.SDK.FactSetConcordance.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Deletes mapping specified by the client. Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <returns>EntityMappingDeleteResponse</returns>
        public EntityMappingDeleteResponse GetEntityMappingDeleteForList(EntityMappingDeleteRequest entityMappingDeleteRequest)
        {
            var localVarResponse = GetEntityMappingDeleteForListWithHttpInfo(entityMappingDeleteRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Deletes mapping specified by the client. Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <returns>ApiResponse of EntityMappingDeleteResponse</returns>
        public ApiResponse<EntityMappingDeleteResponse> GetEntityMappingDeleteForListWithHttpInfo(EntityMappingDeleteRequest entityMappingDeleteRequest)
        {
            // verify the required parameter 'entityMappingDeleteRequest' is set
            if (entityMappingDeleteRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingDeleteRequest' when calling MappingsApi->GetEntityMappingDeleteForList");
            }

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingDeleteRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetEntityMappingDeleteForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Post<
            EntityMappingDeleteResponse>("/factset-concordance/v2/entity-mapping-delete", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityMappingDeleteForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Deletes mapping specified by the client. Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityMappingDeleteResponse</returns>
        public async System.Threading.Tasks.Task<EntityMappingDeleteResponse>GetEntityMappingDeleteForListAsync(EntityMappingDeleteRequest entityMappingDeleteRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetEntityMappingDeleteForListWithHttpInfoAsync(entityMappingDeleteRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Deletes mapping specified by the client. Delete a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and universeId are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingDeleteRequest">A request to delete entity mappings specified by the client</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityMappingDeleteResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityMappingDeleteResponse>> GetEntityMappingDeleteForListWithHttpInfoAsync(EntityMappingDeleteRequest entityMappingDeleteRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'entityMappingDeleteRequest' is set
            if (entityMappingDeleteRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingDeleteRequest' when calling MappingsApi->GetEntityMappingDeleteForList");
            }


            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingDeleteRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetEntityMappingDeleteForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EntityMappingDeleteResponse>("/factset-concordance/v2/entity-mapping-delete", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityMappingDeleteForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>EntityResponse</returns>
        public EntityResponse GetEntityMappingForList(EntityMappingRequest entityMappingRequest)
        {
            var localVarResponse = GetEntityMappingForListWithHttpInfo(entityMappingRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>ApiResponse of EntityResponse</returns>
        public ApiResponse<EntityResponse> GetEntityMappingForListWithHttpInfo(EntityMappingRequest entityMappingRequest)
        {
            // verify the required parameter 'entityMappingRequest' is set
            if (entityMappingRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingRequest' when calling MappingsApi->GetEntityMappingForList");
            }

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetEntityMappingForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Post<
            EntityResponse>("/factset-concordance/v2/entity-mapping", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityMappingForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityResponse</returns>
        public async System.Threading.Tasks.Task<EntityResponse>GetEntityMappingForListAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetEntityMappingForListWithHttpInfoAsync(entityMappingRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityResponse>> GetEntityMappingForListWithHttpInfoAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'entityMappingRequest' is set
            if (entityMappingRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingRequest' when calling MappingsApi->GetEntityMappingForList");
            }


            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetEntityMappingForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EntityResponse>("/factset-concordance/v2/entity-mapping", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityMappingForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe Retrieves all entity mappings within a requested universe. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>EntityUniverseResponse</returns>
        public EntityUniverseResponse GetEntityUniverse(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?))
        {
            var localVarResponse = GetEntityUniverseWithHttpInfo(universeId, clientId, mapStatus, offset, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe Retrieves all entity mappings within a requested universe. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        public ApiResponse<EntityUniverseResponse> GetEntityUniverseWithHttpInfo(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?))
        {
            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "universeId", universeId));
            if (clientId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("csv", "clientId", clientId));
            }
            if (mapStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("multi", "mapStatus", mapStatus));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EntityUniverseResponse>("/factset-concordance/v2/entity-universe", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverse", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe Retrieves all entity mappings within a requested universe. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        public async System.Threading.Tasks.Task<EntityUniverseResponse>GetEntityUniverseAsync(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetEntityUniverseWithHttpInfoAsync(universeId, clientId, mapStatus, offset, limit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe Retrieves all entity mappings within a requested universe. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="universeId">Universe identifier. *To create a universe, use the &#x60;/universe&#39; endpoint.*</param>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseWithHttpInfoAsync(int universeId, List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "universeId", universeId));
            if (clientId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("csv", "clientId", clientId));
            }
            if (mapStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("multi", "mapStatus", mapStatus));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EntityUniverseResponse>("/factset-concordance/v2/entity-universe", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverse", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <returns>EntityUniverseResponse</returns>
        public EntityUniverseResponse GetEntityUniverseForList(EntityUniverseRequest entityUniverseRequest)
        {
            var localVarResponse = GetEntityUniverseForListWithHttpInfo(entityUniverseRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        public ApiResponse<EntityUniverseResponse> GetEntityUniverseForListWithHttpInfo(EntityUniverseRequest entityUniverseRequest)
        {
            // verify the required parameter 'entityUniverseRequest' is set
            if (entityUniverseRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityUniverseRequest' when calling MappingsApi->GetEntityUniverseForList");
            }

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityUniverseRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Post<
            EntityUniverseResponse>("/factset-concordance/v2/entity-universe", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverseForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        public async System.Threading.Tasks.Task<EntityUniverseResponse>GetEntityUniverseForListAsync(EntityUniverseRequest entityUniverseRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetEntityUniverseForListWithHttpInfoAsync(entityUniverseRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve all saved mappings within a requested universe or large list of client ids Retrieves all entity mappings that were saved in a given universe. Supports filtering by a large number of &#x60;clientId&#x60;s 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityUniverseRequest">A request to fetch all entities of a given universe</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseForListWithHttpInfoAsync(EntityUniverseRequest entityUniverseRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'entityUniverseRequest' is set
            if (entityUniverseRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityUniverseRequest' when calling MappingsApi->GetEntityUniverseForList");
            }


            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityUniverseRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseForListResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EntityUniverseResponse>("/factset-concordance/v2/entity-universe", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverseForList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
