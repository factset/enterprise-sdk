/*
 * Open:Risk API
 *
 * Service to calculate parametric linear risk statistics and generate risk model asset identifier mappings.
 *
 * The version of the OpenAPI document: 1.26.0
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.OpenRisk.Client.OpenAPIDateConverter;

namespace FactSet.SDK.OpenRisk.Model
{
    /// <summary>
    /// User-defined values (all required) to compute the desired arbitrary &#39;excess return&#39; of the market portfolio (which is usually intended to be defined as a broad market index).
    /// </summary>
    [DataContract(Name = "AdditionalCalculationInputs_marketExcess")]
    public partial class AdditionalCalculationInputsMarketExcess : IEquatable<AdditionalCalculationInputsMarketExcess>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AdditionalCalculationInputsMarketExcess" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected AdditionalCalculationInputsMarketExcess() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="AdditionalCalculationInputsMarketExcess" /> class.
        /// </summary>
        /// <param name="_return">User-defined arbitrary return value measured from the market portfolio. The value is expected to be a scalar and the return horizon must match that of the factor returns. For example, if the factor returns used are daily-basis, the market return needs to be 1-day market return for the calculation. This number will be one of the inputs to calculate market timing effect. (required).</param>
        /// <param name="riskFreeRate">User-defined risk-free rate of return whose horizon must match that of the factor returns. This number will be one of the inputs to calculate market timing effect. (required).</param>
        /// <param name="riskPremium">Expected return of the market portfolio which is required to be an annualized return. This number will be one of the inputs to calculate market timing effect. (required).</param>
        /// <param name="riskPremiumPeriodsPerYear">Deannualization factor on the Market Risk Premium which can be any user-defined positive integer number. This number will be used to deannualize Market Risk Premium so that the expected market return horizon will match that of the factor returns. For example, if a risk model has daily factor returns, select desired integer such as 365 or 252. (required).</param>
        public AdditionalCalculationInputsMarketExcess(decimal _return, decimal riskFreeRate, decimal riskPremium, int riskPremiumPeriodsPerYear)
        {
            this.Return = _return;
            this.RiskFreeRate = riskFreeRate;
            this.RiskPremium = riskPremium;
            this.RiskPremiumPeriodsPerYear = riskPremiumPeriodsPerYear;
        }

        /// <summary>
        /// User-defined arbitrary return value measured from the market portfolio. The value is expected to be a scalar and the return horizon must match that of the factor returns. For example, if the factor returns used are daily-basis, the market return needs to be 1-day market return for the calculation. This number will be one of the inputs to calculate market timing effect.
        /// </summary>
        /// <value>User-defined arbitrary return value measured from the market portfolio. The value is expected to be a scalar and the return horizon must match that of the factor returns. For example, if the factor returns used are daily-basis, the market return needs to be 1-day market return for the calculation. This number will be one of the inputs to calculate market timing effect.</value>
        [DataMember(Name = "return", IsRequired = true, EmitDefaultValue = false)]
        public decimal Return { get; set; }

        /// <summary>
        /// User-defined risk-free rate of return whose horizon must match that of the factor returns. This number will be one of the inputs to calculate market timing effect.
        /// </summary>
        /// <value>User-defined risk-free rate of return whose horizon must match that of the factor returns. This number will be one of the inputs to calculate market timing effect.</value>
        [DataMember(Name = "riskFreeRate", IsRequired = true, EmitDefaultValue = false)]
        public decimal RiskFreeRate { get; set; }

        /// <summary>
        /// Expected return of the market portfolio which is required to be an annualized return. This number will be one of the inputs to calculate market timing effect.
        /// </summary>
        /// <value>Expected return of the market portfolio which is required to be an annualized return. This number will be one of the inputs to calculate market timing effect.</value>
        [DataMember(Name = "riskPremium", IsRequired = true, EmitDefaultValue = false)]
        public decimal RiskPremium { get; set; }

        /// <summary>
        /// Deannualization factor on the Market Risk Premium which can be any user-defined positive integer number. This number will be used to deannualize Market Risk Premium so that the expected market return horizon will match that of the factor returns. For example, if a risk model has daily factor returns, select desired integer such as 365 or 252.
        /// </summary>
        /// <value>Deannualization factor on the Market Risk Premium which can be any user-defined positive integer number. This number will be used to deannualize Market Risk Premium so that the expected market return horizon will match that of the factor returns. For example, if a risk model has daily factor returns, select desired integer such as 365 or 252.</value>
        [DataMember(Name = "riskPremiumPeriodsPerYear", IsRequired = true, EmitDefaultValue = false)]
        public int RiskPremiumPeriodsPerYear { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AdditionalCalculationInputsMarketExcess {\n");
            sb.Append("  Return: ").Append(Return).Append("\n");
            sb.Append("  RiskFreeRate: ").Append(RiskFreeRate).Append("\n");
            sb.Append("  RiskPremium: ").Append(RiskPremium).Append("\n");
            sb.Append("  RiskPremiumPeriodsPerYear: ").Append(RiskPremiumPeriodsPerYear).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AdditionalCalculationInputsMarketExcess);
        }

        /// <summary>
        /// Returns true if AdditionalCalculationInputsMarketExcess instances are equal
        /// </summary>
        /// <param name="input">Instance of AdditionalCalculationInputsMarketExcess to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AdditionalCalculationInputsMarketExcess input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Return == input.Return ||
                    this.Return.Equals(input.Return)
                ) && 
                (
                    this.RiskFreeRate == input.RiskFreeRate ||
                    this.RiskFreeRate.Equals(input.RiskFreeRate)
                ) && 
                (
                    this.RiskPremium == input.RiskPremium ||
                    this.RiskPremium.Equals(input.RiskPremium)
                ) && 
                (
                    this.RiskPremiumPeriodsPerYear == input.RiskPremiumPeriodsPerYear ||
                    this.RiskPremiumPeriodsPerYear.Equals(input.RiskPremiumPeriodsPerYear)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Return.GetHashCode();
                hashCode = (hashCode * 59) + this.RiskFreeRate.GetHashCode();
                hashCode = (hashCode * 59) + this.RiskPremium.GetHashCode();
                hashCode = (hashCode * 59) + this.RiskPremiumPeriodsPerYear.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // RiskPremiumPeriodsPerYear (int) maximum
            if (this.RiskPremiumPeriodsPerYear > (int)365)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RiskPremiumPeriodsPerYear, must be a value less than or equal to 365.", new [] { "RiskPremiumPeriodsPerYear" });
            }

            // RiskPremiumPeriodsPerYear (int) minimum
            if (this.RiskPremiumPeriodsPerYear < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RiskPremiumPeriodsPerYear, must be a value greater than or equal to 1.", new [] { "RiskPremiumPeriodsPerYear" });
            }

            yield break;
        }
    }

}
