/**
 * VRS API documentation
 * Documentation on all available end points in the VRSAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ErrorList from '../model/ErrorList';
import GenerateScheduleResponse from '../model/GenerateScheduleResponse';
import ScheduleDefinitionsList from '../model/ScheduleDefinitionsList';
import ScheduleGenerationLogList from '../model/ScheduleGenerationLogList';
import ScheduleResponseData from '../model/ScheduleResponseData';
import ScheduleStatusUpdateResponse from '../model/ScheduleStatusUpdateResponse';
import SchedulesList from '../model/SchedulesList';
import TaskDetailsObject from '../model/TaskDetailsObject';
import TaskHistoryList from '../model/TaskHistoryList';
import TaskList from '../model/TaskList';
import TaskPatchRequestBody from '../model/TaskPatchRequestBody';
import TaskPatchResponseObject from '../model/TaskPatchResponseObject';

/**
* Workflow service.
* @module api/WorkflowApi
*/
export default class WorkflowApi {

    /**
    * Constructs a new WorkflowApi. 
    * @alias module:api/WorkflowApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Creates schedule for the specified schedule definition
     * Creates schedule for the specified Schedule Definition code and sets to running based on the param in the JSON in the request body
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleDefinitionCode The schedule definition code for which to generate the schedule
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.setToRunning This parameter is used to set the generated schedule's status to Running.If parameter is set to true, the generated schedule will be set to Running. If no value is provided, the schedule will remain in Initialised status.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GenerateScheduleResponse} and HTTP response
     */
    generateScheduleWithHttpInfo(tenant, scheduleDefinitionCode, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateSchedule");
      }
      // verify the required parameter 'scheduleDefinitionCode' is set
      if (scheduleDefinitionCode === undefined || scheduleDefinitionCode === null) {
        throw new Error("Missing the required parameter 'scheduleDefinitionCode' when calling generateSchedule");
      }

      let pathParams = {
        'tenant': tenant,
        'scheduleDefinitionCode': scheduleDefinitionCode
      };
      let queryParams = {
        'setToRunning': opts['setToRunning']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = GenerateScheduleResponse;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules/{scheduleDefinitionCode}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Creates schedule for the specified schedule definition
     * Creates schedule for the specified Schedule Definition code and sets to running based on the param in the JSON in the request body
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleDefinitionCode The schedule definition code for which to generate the schedule
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.setToRunning This parameter is used to set the generated schedule's status to Running.If parameter is set to true, the generated schedule will be set to Running. If no value is provided, the schedule will remain in Initialised status.
     * @return { Promise.< module:model/GenerateScheduleResponse > } a Promise, with data of type {@link module:model/GenerateScheduleResponse }
     */
    generateSchedule(tenant, scheduleDefinitionCode, opts) {
      return this.generateScheduleWithHttpInfo(tenant, scheduleDefinitionCode, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Generates the tasks for the initialised schedule
     * Generates the schedule tasks for the specified schedule id
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The schedule id for which to generate the tasks
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ScheduleStatusUpdateResponse} and HTTP response
     */
    generateScheduleTasksWithHttpInfo(tenant, scheduleId) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateScheduleTasks");
      }
      // verify the required parameter 'scheduleId' is set
      if (scheduleId === undefined || scheduleId === null) {
        throw new Error("Missing the required parameter 'scheduleId' when calling generateScheduleTasks");
      }

      let pathParams = {
        'tenant': tenant,
        'scheduleId': scheduleId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = ScheduleStatusUpdateResponse;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules/{scheduleId}/generate-tasks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Generates the tasks for the initialised schedule
     * Generates the schedule tasks for the specified schedule id
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The schedule id for which to generate the tasks
     * @return { Promise.< module:model/ScheduleStatusUpdateResponse > } a Promise, with data of type {@link module:model/ScheduleStatusUpdateResponse }
     */
    generateScheduleTasks(tenant, scheduleId) {
      return this.generateScheduleTasksWithHttpInfo(tenant, scheduleId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets a schedule based on the schedule ID
     * Gets a schedule Object based on the schedule ID passed.
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The Id of the schedule
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ScheduleResponseData} and HTTP response
     */
    getScheduleByIdWithHttpInfo(tenant, scheduleId) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getScheduleById");
      }
      // verify the required parameter 'scheduleId' is set
      if (scheduleId === undefined || scheduleId === null) {
        throw new Error("Missing the required parameter 'scheduleId' when calling getScheduleById");
      }

      let pathParams = {
        'tenant': tenant,
        'scheduleId': scheduleId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = ScheduleResponseData;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules/{scheduleId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets a schedule based on the schedule ID
     * Gets a schedule Object based on the schedule ID passed.
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The Id of the schedule
     * @return { Promise.< module:model/ScheduleResponseData > } a Promise, with data of type {@link module:model/ScheduleResponseData }
     */
    getScheduleById(tenant, scheduleId) {
      return this.getScheduleByIdWithHttpInfo(tenant, scheduleId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieves a list of all schedule definitions
     * Retrieves all schedule definitions the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.scheduleType Acts as a filter for the retrieval process. Filters the schedule definitions that match the given schedule type. Accepts multiple values separated by a comma, e.g. ?scheduleType=REPEATING,MANUAL
     * @param {module:model/String} opts.reportDate Acts as a filter for the retrieval process. Filters the schedule definitions that match the given schedule report date.  Accepts multiple values separated by a comma, e.g. ?reportDate=LAST_DAY_OF_PREV_MONTH,CREATION_DATE
     * @param {String} opts.lastUpdatedBy Acts as a filter for the retrieval process. Filters the schedule definitions where the provided parameter value matches or is a substring of the last updated by value of the schedule definitions
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the schedule definitions based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the schedule definitions based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ScheduleDefinitionsList} and HTTP response
     */
    getScheduleDefinitionsWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getScheduleDefinitions");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'scheduleType': opts['scheduleType'],
        'reportDate': opts['reportDate'],
        'lastUpdatedBy': opts['lastUpdatedBy'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate'],
        '_sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        '_paginationLimit': opts['paginationLimit'],
        '_paginationOffset': opts['paginationOffset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = ScheduleDefinitionsList;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedule-definitions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieves a list of all schedule definitions
     * Retrieves all schedule definitions the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.scheduleType Acts as a filter for the retrieval process. Filters the schedule definitions that match the given schedule type. Accepts multiple values separated by a comma, e.g. ?scheduleType=REPEATING,MANUAL
     * @param {module:model/String} opts.reportDate Acts as a filter for the retrieval process. Filters the schedule definitions that match the given schedule report date.  Accepts multiple values separated by a comma, e.g. ?reportDate=LAST_DAY_OF_PREV_MONTH,CREATION_DATE
     * @param {String} opts.lastUpdatedBy Acts as a filter for the retrieval process. Filters the schedule definitions where the provided parameter value matches or is a substring of the last updated by value of the schedule definitions
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the schedule definitions based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the schedule definitions based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return { Promise.< module:model/ScheduleDefinitionsList > } a Promise, with data of type {@link module:model/ScheduleDefinitionsList }
     */
    getScheduleDefinitions(tenant, opts) {
      return this.getScheduleDefinitionsWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets the generation logs for a specific schedule
     * Gets the generation logs for a specific schedule based on the Schedule ID. Allows the user to sort and filter logs.
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The scheduleId for which the logs are requested
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.type Acts as a filter for the retrieval process. Filters the log instances that match the input type
     * @param {String} opts.message Acts as a filter for the retrieval process. Filters the log instances that match the input message
     * @param {String} opts.logSet Acts as a filter for the retrieval process. Filters the log instances that match the input logset
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the log instances based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the log instances based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add - to sort
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ScheduleGenerationLogList} and HTTP response
     */
    getScheduleGenerationLogsWithHttpInfo(tenant, scheduleId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getScheduleGenerationLogs");
      }
      // verify the required parameter 'scheduleId' is set
      if (scheduleId === undefined || scheduleId === null) {
        throw new Error("Missing the required parameter 'scheduleId' when calling getScheduleGenerationLogs");
      }

      let pathParams = {
        'tenant': tenant,
        'scheduleId': scheduleId
      };
      let queryParams = {
        'type': opts['type'],
        'message': opts['message'],
        'logSet': opts['logSet'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate'],
        '_sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        '_paginationLimit': opts['paginationLimit'],
        '_paginationOffset': opts['paginationOffset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = ScheduleGenerationLogList;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules/{scheduleId}/logs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets the generation logs for a specific schedule
     * Gets the generation logs for a specific schedule based on the Schedule ID. Allows the user to sort and filter logs.
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The scheduleId for which the logs are requested
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.type Acts as a filter for the retrieval process. Filters the log instances that match the input type
     * @param {String} opts.message Acts as a filter for the retrieval process. Filters the log instances that match the input message
     * @param {String} opts.logSet Acts as a filter for the retrieval process. Filters the log instances that match the input logset
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the log instances based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the log instances based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add - to sort
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return { Promise.< module:model/ScheduleGenerationLogList > } a Promise, with data of type {@link module:model/ScheduleGenerationLogList }
     */
    getScheduleGenerationLogs(tenant, scheduleId, opts) {
      return this.getScheduleGenerationLogsWithHttpInfo(tenant, scheduleId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieves a list of all schedules
     * Retrieves all schedules the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.status Acts as a filter for the retrieval process. Filters the schedules that match the given status. Accepts multiple values separated by a comma, e.g. ?status=INITIALISED,RUNNING
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the schedules based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the schedules based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/SchedulesList} and HTTP response
     */
    getSchedulesWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getSchedules");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'status': opts['status'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate'],
        '_sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        '_paginationLimit': opts['paginationLimit'],
        '_paginationOffset': opts['paginationOffset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = SchedulesList;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieves a list of all schedules
     * Retrieves all schedules the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.status Acts as a filter for the retrieval process. Filters the schedules that match the given status. Accepts multiple values separated by a comma, e.g. ?status=INITIALISED,RUNNING
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the schedules based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the schedules based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return { Promise.< module:model/SchedulesList > } a Promise, with data of type {@link module:model/SchedulesList }
     */
    getSchedules(tenant, opts) {
      return this.getSchedulesWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets a task based on the task ID
     * Gets a task Object based on the task ID passed.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The Id of the task
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TaskDetailsObject} and HTTP response
     */
    getTaskWithHttpInfo(tenant, taskId) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getTask");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling getTask");
      }

      let pathParams = {
        'tenant': tenant,
        'taskId': taskId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = TaskDetailsObject;

      return this.apiClient.callApi(
        '/v1/{tenant}/tasks/{taskId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets a task based on the task ID
     * Gets a task Object based on the task ID passed.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The Id of the task
     * @return { Promise.< module:model/TaskDetailsObject > } a Promise, with data of type {@link module:model/TaskDetailsObject }
     */
    getTask(tenant, taskId) {
      return this.getTaskWithHttpInfo(tenant, taskId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets the task history for a specific task
     * Gets the task history for a specific task based on the Task ID. Allows the user to sort and filter the task history entries.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The taskId for which the history of the specific task is requested
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.actionType Acts as a filter for the retrieval process. Filters the task history entries that match the given action type
     * @param {String} opts.reasonCode Acts as a filter for the retrieval process. Filters the task history entries that match the given reason code
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the task history events based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the task history events based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add - to sort for descending order
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TaskHistoryList} and HTTP response
     */
    getTaskHistoryWithHttpInfo(tenant, taskId, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getTaskHistory");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling getTaskHistory");
      }

      let pathParams = {
        'tenant': tenant,
        'taskId': taskId
      };
      let queryParams = {
        'actionType': opts['actionType'],
        'reasonCode': opts['reasonCode'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate'],
        '_sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        '_paginationLimit': opts['paginationLimit'],
        '_paginationOffset': opts['paginationOffset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = TaskHistoryList;

      return this.apiClient.callApi(
        '/v1/{tenant}/tasks/{taskId}/history', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets the task history for a specific task
     * Gets the task history for a specific task based on the Task ID. Allows the user to sort and filter the task history entries.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The taskId for which the history of the specific task is requested
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.actionType Acts as a filter for the retrieval process. Filters the task history entries that match the given action type
     * @param {String} opts.reasonCode Acts as a filter for the retrieval process. Filters the task history entries that match the given reason code
     * @param {String} opts.startDate Acts as a filter for the retrieval process. Filters the task history events based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {String} opts.endDate Acts as a filter for the retrieval process. Filters the task history events based on their last updated date, the input date must be of the date format (d MMMMM yyyy 00:00:00).
     * @param {Array.<String>} opts.sort The column to sort on. Can add - to sort for descending order
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return { Promise.< module:model/TaskHistoryList > } a Promise, with data of type {@link module:model/TaskHistoryList }
     */
    getTaskHistory(tenant, taskId, opts) {
      return this.getTaskHistoryWithHttpInfo(tenant, taskId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieves a list of all tasks
     * Retrieves all tasks the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.taskType Acts as a filter for the retrieval process. Filters the tasks that match the given task type. Accepts multiple values separated by a comma, e.g. ?taskType=SIGNOFF_DATA,PACKAGE_REPORTS
     * @param {module:model/String} opts.status Acts as a filter for the retrieval process. Filters the tasks that match the given status. Accepts multiple values separated by a comma, e.g. ?status=PENDING,AWAITING_CORRECTION
     * @param {String} opts.role Acts as a filter for the retrieval process. Filters the tasks that match the input role assigned to the task
     * @param {String} opts.user Acts as a filter for the retrieval process. Filters the tasks that match the input user name assigned to the task
     * @param {Boolean} opts.immediateTasksOnly Acts as a filter for the retrieval process. Filters the immediate tasks if the parameter value is set to true
     * @param {Number} opts.scheduleId Acts as a filter for the retrieval process. Filters the schedule tasks for the Schedule Id passed in the parameter value
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TaskList} and HTTP response
     */
    getTasksWithHttpInfo(tenant, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getTasks");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'taskType': opts['taskType'],
        'status': opts['status'],
        'role': opts['role'],
        'user': opts['user'],
        'immediateTasksOnly': opts['immediateTasksOnly'],
        'scheduleId': opts['scheduleId'],
        '_sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        '_paginationLimit': opts['paginationLimit'],
        '_paginationOffset': opts['paginationOffset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = TaskList;

      return this.apiClient.callApi(
        '/v1/{tenant}/tasks', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieves a list of all tasks
     * Retrieves all tasks the user has permissions for. User has sort and filter parameters available to use.
     * @param {String} tenant The code of the tenancy
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.taskType Acts as a filter for the retrieval process. Filters the tasks that match the given task type. Accepts multiple values separated by a comma, e.g. ?taskType=SIGNOFF_DATA,PACKAGE_REPORTS
     * @param {module:model/String} opts.status Acts as a filter for the retrieval process. Filters the tasks that match the given status. Accepts multiple values separated by a comma, e.g. ?status=PENDING,AWAITING_CORRECTION
     * @param {String} opts.role Acts as a filter for the retrieval process. Filters the tasks that match the input role assigned to the task
     * @param {String} opts.user Acts as a filter for the retrieval process. Filters the tasks that match the input user name assigned to the task
     * @param {Boolean} opts.immediateTasksOnly Acts as a filter for the retrieval process. Filters the immediate tasks if the parameter value is set to true
     * @param {Number} opts.scheduleId Acts as a filter for the retrieval process. Filters the schedule tasks for the Schedule Id passed in the parameter value
     * @param {Array.<String>} opts.sort The column to sort on. Can add '-' to the start of the parameter value to sort in descending order.
     * @param {Number} opts.paginationLimit Non-negative maximum number of entries to return (default to 25)
     * @param {Number} opts.paginationOffset Non-negative number of entries to skip (default to 0)
     * @return { Promise.< module:model/TaskList > } a Promise, with data of type {@link module:model/TaskList }
     */
    getTasks(tenant, opts) {
      return this.getTasksWithHttpInfo(tenant, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update schedule status for specified schedule
     * Updated the schedule status for the specified schedule id based on the given status
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The schedule id for which to update the status
     * @param {module:model/String} status The schedule status that needs to be updated only if the transition is valid
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ScheduleStatusUpdateResponse} and HTTP response
     */
    updateScheduleStatusWithHttpInfo(tenant, scheduleId, status) {
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateScheduleStatus");
      }
      // verify the required parameter 'scheduleId' is set
      if (scheduleId === undefined || scheduleId === null) {
        throw new Error("Missing the required parameter 'scheduleId' when calling updateScheduleStatus");
      }
      // verify the required parameter 'status' is set
      if (status === undefined || status === null) {
        throw new Error("Missing the required parameter 'status' when calling updateScheduleStatus");
      }

      let pathParams = {
        'tenant': tenant,
        'scheduleId': scheduleId,
        'status': status
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = [];
      let accepts = ['application/json'];


      let returnType = ScheduleStatusUpdateResponse;

      return this.apiClient.callApi(
        '/v1/{tenant}/schedules/{scheduleId}/{status}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update schedule status for specified schedule
     * Updated the schedule status for the specified schedule id based on the given status
     * @param {String} tenant The code of the tenancy
     * @param {String} scheduleId The schedule id for which to update the status
     * @param {module:model/String} status The schedule status that needs to be updated only if the transition is valid
     * @return { Promise.< module:model/ScheduleStatusUpdateResponse > } a Promise, with data of type {@link module:model/ScheduleStatusUpdateResponse }
     */
    updateScheduleStatus(tenant, scheduleId, status) {
      return this.updateScheduleStatusWithHttpInfo(tenant, scheduleId, status)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updates the task details for the specified task.
     * Updates the task details for the specified task.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The unique identifier for task
     * @param {module:model/TaskPatchRequestBody} taskPatchRequestBody 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TaskPatchResponseObject} and HTTP response
     */
    updateTaskDetailsWithHttpInfo(tenant, taskId, taskPatchRequestBody) {
      let postBody = taskPatchRequestBody;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateTaskDetails");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling updateTaskDetails");
      }
      // verify the required parameter 'taskPatchRequestBody' is set
      if (taskPatchRequestBody === undefined || taskPatchRequestBody === null) {
        throw new Error("Missing the required parameter 'taskPatchRequestBody' when calling updateTaskDetails");
      }

      let pathParams = {
        'tenant': tenant,
        'taskId': taskId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['FactSetApiKey', 'FactSetOAuth2'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];


      let returnType = TaskPatchResponseObject;

      return this.apiClient.callApi(
        '/v1/{tenant}/tasks/{taskId}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updates the task details for the specified task.
     * Updates the task details for the specified task.
     * @param {String} tenant The code of the tenancy
     * @param {String} taskId The unique identifier for task
     * @param {module:model/TaskPatchRequestBody} taskPatchRequestBody 
     * @return { Promise.< module:model/TaskPatchResponseObject > } a Promise, with data of type {@link module:model/TaskPatchResponseObject }
     */
    updateTaskDetails(tenant, taskId, taskPatchRequestBody) {
      return this.updateTaskDetailsWithHttpInfo(tenant, taskId, taskPatchRequestBody)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}





